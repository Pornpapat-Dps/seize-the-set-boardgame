<!DOCTYPE html>
<html lang="th">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
<title>Seize The Set Boardgame - เกมยึดครองเซต</title>
<style>
  :root {
    --primary: #ff4f9a;
    --secondary: #7c3aed;
    --dark: #1f2937;
    --light: #f8fafc;
    --success: #10b981;
    --warning: #f59e0b;
    --danger: #ef4444;
  }

  * {
    margin: 0;
    padding: 0;
    box-sizing: border-box;
  }

  body {
    font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
    background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
    min-height: 100vh;
    color: var(--dark);
  }

  .container {
    max-width: 1400px;
    margin: 0 auto;
    padding: 20px;
  }
  
  /* Responsive สำหรับหน้าจอขนาดต่างๆ */
  @media (max-width: 768px) {
    .container {
      padding: 10px;
    }
  }

  .header {
    text-align: center;
    background: white;
    border-radius: 15px;
    padding: 30px;
    margin-bottom: 30px;
    box-shadow: 0 10px 30px rgba(0,0,0,0.1);
  }

  .header h1 {
    font-size: 2.5rem;
    background: linear-gradient(45deg, var(--primary), var(--secondary));
    -webkit-background-clip: text;
    background-clip: text;
    -webkit-text-fill-color: transparent;
    margin-bottom: 10px;
  }
  
  /* Responsive Header */
  @media (max-width: 768px) {
    .header {
      padding: 20px;
      margin-bottom: 20px;
    }
    
    .header h1 {
      font-size: 1.8rem;
    }
  }
  
  @media (max-width: 480px) {
    .header h1 {
      font-size: 1.5rem;
    }
  }

  .game-area {
    display: grid;
    grid-template-columns: 1fr 400px;
    gap: 30px;
    margin-bottom: 30px;
  }
  
  /* Responsive Game Area */
  @media (max-width: 1024px) {
    .game-area {
      grid-template-columns: 1fr 350px;
      gap: 20px;
    }
  }
  
  @media (max-width: 768px) {
    .game-area {
      grid-template-columns: 1fr;
      gap: 20px;
      margin-bottom: 20px;
    }
  }

  .board-section {
    background: white;
    border-radius: 15px;
    padding: 25px;
    box-shadow: 0 10px 30px rgba(0,0,0,0.1);
  }

  .control-panel {
    background: white;
    border-radius: 15px;
    padding: 25px;
    box-shadow: 0 10px 30px rgba(0,0,0,0.1);
  }
  
  /* Responsive Panels */
  @media (max-width: 768px) {
    .board-section, .control-panel {
      padding: 15px;
    }
  }
  
  @media (max-width: 480px) {
    .board-section, .control-panel {
      padding: 12px;
    }
  }

  .card-info-panel {
    background: white;
    border-radius: 15px;
    padding: 25px;
    margin-bottom: 30px;
    box-shadow: 0 10px 30px rgba(0,0,0,0.1);
  }

  .toggle-card-info {
    background: var(--primary);
    color: white;
    border: none;
    border-radius: 10px;
    padding: 12px 20px;
    font-weight: bold;
    cursor: pointer;
    transition: all 0.3s ease;
    margin-bottom: 20px;
    display: flex;
    align-items: center;
    gap: 10px;
    width: 100%;
    justify-content: center;
  }

  .toggle-card-info:hover {
    background: var(--secondary);
    transform: translateY(-2px);
  }

  .card-info-content {
    display: none;
    animation: slideDown 0.3s ease;
  }

  .card-info-content.show {
    display: block;
  }

  @keyframes slideDown {
    from {
      opacity: 0;
      transform: translateY(-20px);
    }
    to {
      opacity: 1;
      transform: translateY(0);
    }
  }

  .card-info-grid {
    display: grid;
    grid-template-columns: 1fr 1fr;
    gap: 30px;
  }

  .card-category {
    background: linear-gradient(135deg, #f8fafc 0%, #e2e8f0 100%);
    border-radius: 10px;
    padding: 20px;
    border-left: 4px solid var(--primary);
  }

  .card-category h4 {
    color: var(--primary);
    margin-bottom: 15px;
    font-size: 1.2rem;
    display: flex;
    align-items: center;
    gap: 10px;
  }

  .card-list {
    display: grid;
    grid-template-columns: 1fr 1fr;
    gap: 10px;
  }

  .card-item {
    background: white;
    border-radius: 8px;
    padding: 12px;
    display: flex;
    justify-content: space-between;
    align-items: center;
    border: 1px solid #e2e8f0;
    transition: all 0.3s ease;
  }

  .card-item:hover {
    border-color: var(--primary);
    transform: translateY(-2px);
    box-shadow: 0 4px 12px rgba(0,0,0,0.1);
  }

  .card-name {
    font-weight: 600;
    color: var(--dark);
  }

  .card-count {
    background: var(--primary);
    color: white;
    border-radius: 20px;
    padding: 4px 12px;
    font-size: 0.9rem;
    font-weight: bold;
  }

  .total-cards {
    text-align: center;
    margin-top: 20px;
    padding: 15px;
    background: linear-gradient(45deg, var(--primary), var(--secondary));
    color: white;
    border-radius: 10px;
    font-weight: bold;
    font-size: 1.1rem;
  }

  .game-board {
    display: grid;
    grid-template-columns: 40px repeat(8, 60px);
    grid-template-rows: 40px repeat(8, 60px);
    gap: 3px;
    margin: 20px auto;
    background: var(--dark);
    padding: 10px;
    border-radius: 10px;
    max-width: 100%;
    overflow-x: auto;
    box-shadow: 0 8px 25px rgba(0,0,0,0.15);
    transition: box-shadow 0.3s ease;
  }

  .game-board:hover {
    box-shadow: 0 12px 35px rgba(0,0,0,0.2);
  }
  
  /* Responsive Game Board */
  @media (max-width: 768px) {
    .game-board {
      grid-template-columns: 30px repeat(8, 45px);
      grid-template-rows: 30px repeat(8, 45px);
      gap: 2px;
      padding: 8px;
    }
  }
  
  @media (max-width: 480px) {
    .game-board {
      grid-template-columns: 25px repeat(8, 35px);
      grid-template-rows: 25px repeat(8, 35px);
      gap: 1px;
      padding: 6px;
    }
  }

  .cell {
    display: flex;
    align-items: center;
    justify-content: center;
    background: white;
    border-radius: 5px;
    font-weight: bold;
    font-size: 0.9rem;
    position: relative;
    cursor: pointer;
    transition: all 0.3s ease;
  }

  .cell.header {
    background: var(--dark);
    color: white;
    font-size: 0.8rem;
  }
  
  /* Responsive Cell */
  @media (max-width: 768px) {
    .cell {
      font-size: 0.7rem;
    }
    
    .cell.header {
      font-size: 0.6rem;
    }
  }
  
  @media (max-width: 480px) {
    .cell {
      font-size: 0.6rem;
    }
    
    .cell.header {
      font-size: 0.5rem;
    }
  }

  .cell.game-cell {
    min-height: 60px;
    border: 2px solid transparent;
  }

  .cell.game-cell:hover {
    border-color: var(--warning);
    transform: scale(1.05);
  }

  .chip {
    width: 40px;
    height: 40px;
    border-radius: 50%;
    display: flex;
    align-items: center;
    justify-content: center;
    font-weight: bold;
    color: white;
    text-shadow: 1px 1px 2px rgba(0,0,0,0.5);
    animation: chipPlace 0.5s ease-out;
  }

  @keyframes chipPlace {
    0% {
      transform: scale(0) rotate(180deg);
      opacity: 0;
    }
    50% {
      transform: scale(1.2) rotate(90deg);
      opacity: 0.8;
    }
    100% {
      transform: scale(1) rotate(0deg);
      opacity: 1;
    }
  }

  .chip.black {
    background: linear-gradient(145deg, #374151, #111827);
    box-shadow: inset 2px 2px 5px rgba(255,255,255,0.2), inset -2px -2px 5px rgba(0,0,0,0.5);
  }

  .chip.white {
    background: linear-gradient(145deg, #f9fafb, #e5e7eb);
    color: var(--dark);
    box-shadow: inset 2px 2px 5px rgba(255,255,255,0.8), inset -2px -2px 5px rgba(0,0,0,0.1);
  }
  
  /* Responsive Chip */
  @media (max-width: 768px) {
    .chip {
      width: 30px;
      height: 30px;
      font-size: 0.8rem;
    }
    
    .cell.game-cell {
      min-height: 45px;
    }
  }
  
  @media (max-width: 480px) {
    .chip {
      width: 25px;
      height: 25px;
      font-size: 0.7rem;
    }
    
    .cell.game-cell {
      min-height: 35px;
    }
  }

  .score-display {
    display: flex;
    justify-content: space-between;
    align-items: center;
    background: linear-gradient(135deg, #f0f4f8, #e2e8f0);
    padding: 20px;
    border-radius: 10px;
    margin-bottom: 20px;
  }

  .player-score {
    display: flex;
    align-items: center;
    gap: 10px;
  }

  .player-score .chip {
    width: 30px;
    height: 30px;
    font-size: 0.8rem;
  }

  .turn-info {
    background: var(--primary);
    color: white;
    padding: 15px;
    border-radius: 10px;
    text-align: center;
    margin-bottom: 20px;
    font-weight: bold;
    font-size: 1.1rem;
    transition: all 0.3s ease;
    box-shadow: 0 4px 15px rgba(0,0,0,0.1);
  }

  .turn-info.active {
    animation: subtlePulse 2s infinite;
  }

  @keyframes subtlePulse {
    0%, 100% {
      box-shadow: 0 4px 15px rgba(0,0,0,0.1);
    }
    50% {
      box-shadow: 0 8px 25px rgba(0,0,0,0.2);
    }
  }

  .turn-info.black-turn {
    background: linear-gradient(135deg, #374151, #111827);
  }

  .turn-info.white-turn {
    background: linear-gradient(135deg, #f9fafb, #e5e7eb);
    color: var(--dark);
  }

  .current-player-indicator {
    display: inline-flex;
    align-items: center;
    gap: 8px;
    font-size: 1.2rem;
  }

  .actions {
    display: grid;
    grid-template-columns: 1fr 1fr;
    gap: 10px;
    margin-bottom: 20px;
  }

  .btn {
    padding: 12px 20px;
    border: none;
    border-radius: 8px;
    font-weight: bold;
    cursor: pointer;
    transition: all 0.3s ease;
    font-size: 0.9rem;
    outline: none;
    position: relative;
  }

  .btn:focus-visible {
    outline: 2px solid var(--primary);
    outline-offset: 2px;
    box-shadow: 0 0 0 4px rgba(255, 79, 154, 0.2);
  }
  
  /* Responsive Buttons */
  @media (max-width: 768px) {
    .actions {
      grid-template-columns: 1fr;
      gap: 8px;
    }
    
    .btn {
      padding: 10px 16px;
      font-size: 0.8rem;
    }
  }
  
  @media (max-width: 480px) {
    .btn {
      padding: 8px 12px;
      font-size: 0.75rem;
    }
  }

  .btn:hover {
    transform: translateY(-2px);
    box-shadow: 0 5px 15px rgba(0,0,0,0.2);
  }

  .btn.primary {
    background: var(--primary);
    color: white;
  }

  .btn.secondary {
    background: var(--secondary);
    color: white;
  }

  .btn.success {
    background: var(--success);
    color: white;
  }

  .btn.warning {
    background: var(--warning);
    color: white;
  }

  .btn.danger {
    background: var(--danger);
    color: white;
  }

  .btn:disabled {
    opacity: 0.5;
    cursor: not-allowed;
    transform: none;
  }

  .btn.loading {
    position: relative;
    color: transparent;
  }

  .btn.loading::after {
    content: '';
    position: absolute;
    top: 50%;
    left: 50%;
    width: 20px;
    height: 20px;
    border: 2px solid rgba(255, 255, 255, 0.3);
    border-top: 2px solid white;
    border-radius: 50%;
    animation: spin 1s linear infinite;
    transform: translate(-50%, -50%);
  }

  @keyframes spin {
    0% { transform: translate(-50%, -50%) rotate(0deg); }
    100% { transform: translate(-50%, -50%) rotate(360deg); }
  }

  /* Toast Notification System */
  .toast-container {
    position: fixed;
    top: 20px;
    right: 20px;
    z-index: 1000;
    display: flex;
    flex-direction: column;
    gap: 10px;
  }

  .toast {
    background: white;
    border-radius: 10px;
    padding: 15px 20px;
    box-shadow: 0 5px 20px rgba(0,0,0,0.2);
    border-left: 4px solid;
    min-width: 300px;
    max-width: 400px;
    animation: slideInRight 0.3s ease, fadeOut 0.3s ease 4.7s forwards;
    display: flex;
    align-items: center;
    gap: 10px;
  }

  .toast.success {
    border-left-color: var(--success);
  }

  .toast.warning {
    border-left-color: var(--warning);
  }

  .toast.error {
    border-left-color: var(--danger);
  }

  .toast.info {
    border-left-color: var(--primary);
  }

  .toast-icon {
    font-size: 1.2rem;
  }

  .toast-message {
    flex: 1;
    font-weight: 500;
  }

  .toast-close {
    background: none;
    border: none;
    font-size: 1.2rem;
    cursor: pointer;
    opacity: 0.6;
    transition: opacity 0.2s;
  }

  .toast-close:hover {
    opacity: 1;
  }

  @keyframes slideInRight {
    from {
      transform: translateX(100%);
      opacity: 0;
    }
    to {
      transform: translateX(0);
      opacity: 1;
    }
  }

  @keyframes fadeOut {
    to {
      opacity: 0;
      transform: translateX(100%);
    }
  }

  /* Responsive Toast */
  @media (max-width: 768px) {
    .toast-container {
      top: 10px;
      right: 10px;
      left: 10px;
    }
    
    .toast {
      min-width: auto;
      max-width: none;
    }
  }

  .hand {
    background: #f8fafc;
    border-radius: 10px;
    padding: 15px;
    margin-bottom: 20px;
  }

  .hand h4 {
    margin-bottom: 10px;
    color: var(--dark);
  }

  .cards {
    display: flex;
    flex-wrap: wrap;
    gap: 8px;
  }

  .card {
    background: white;
    border: 2px solid var(--dark);
    border-radius: 8px;
    padding: 8px 12px;
    font-size: 0.8rem;
    cursor: pointer;
    transition: all 0.3s ease;
    position: relative;
    outline: none;
    box-shadow: 0 2px 8px rgba(0,0,0,0.1);
  }

  .card .card-details {
    font-size: 0.7rem;
    color: #666;
    margin-top: 4px;
    line-height: 1.2;
    transition: color 0.3s ease;
  }

  .card:hover {
    background: var(--primary);
    color: white;
    transform: scale(1.05) translateY(-2px);
    box-shadow: 0 8px 25px rgba(0,0,0,0.15);
  }

  .card:hover .card-details {
    color: rgba(255,255,255,0.8);
  }

  .card:focus-visible {
    outline: 2px solid var(--primary);
    outline-offset: 2px;
  }

  .card:active {
    transform: scale(0.98);
  }
  
  /* Responsive Cards */
  @media (max-width: 768px) {
    .hand {
      padding: 12px;
    }
    
    .cards {
      gap: 6px;
    }
    
    .card {
      padding: 6px 10px;
      font-size: 0.7rem;
    }
    
    .card .card-details {
      font-size: 0.6rem;
    }
  }
  
  @media (max-width: 480px) {
    .hand {
      padding: 10px;
    }
    
    .card {
      padding: 4px 8px;
      font-size: 0.65rem;
    }
    
    .card .card-details {
      font-size: 0.55rem;
    }
  }

  .card.set {
    border-color: var(--success);
  }

  .card.marker {
    border-color: var(--secondary);
  }

  .card.selected {
    background: var(--warning);
    color: white;
    transform: scale(1.02) translateY(-4px);
    box-shadow: 0 8px 25px rgba(255,193,7,0.4);
    border-color: var(--warning);
  }

  .card.selected .card-details {
    color: rgba(255,255,255,0.9);
  }

  .game-log {
    background: #f8fafc;
    border-radius: 10px;
    padding: 15px;
    height: 200px;
    overflow-y: auto;
  }

  .log-entry {
    padding: 8px 0;
    border-bottom: 1px solid #e2e8f0;
    font-size: 0.9rem;
    animation: fadeInSlide 0.3s ease-out;
    transition: background-color 0.2s ease;
  }

  .log-entry:hover {
    background-color: rgba(59, 130, 246, 0.05);
  }

  @keyframes fadeInSlide {
    0% {
      opacity: 0;
      transform: translateX(-10px);
    }
    100% {
      opacity: 1;
      transform: translateX(0);
    }
  }

  .status-bar {
    background: linear-gradient(135deg, #e2e8f0, #cbd5e1);
    padding: 10px 15px;
    border-radius: 8px;
    margin-bottom: 15px;
    font-size: 0.9rem;
  }

  @media (max-width: 1200px) {
    .game-area {
      grid-template-columns: 1fr;
    }
    
    .game-board {
      grid-template-columns: 30px repeat(8, 45px);
      grid-template-rows: 30px repeat(8, 45px);
    }
    
    .cell.game-cell {
      min-height: 45px;
    }
    
    .chip {
      width: 30px;
      height: 30px;
    }
  }
</style>
</head>
<body>
  <div class="container">
    <div class="header">
      <h1>🎯 Seize The Set Boardgame</h1>
      <p>เกมยึดครองพื้นที่เซต - ผลัดกันเล่น 20 เทิร์น</p>
    </div>

    <div class="card-info-panel">
      <button class="toggle-card-info" onclick="toggleCardInfo()">
        <span id="toggle-icon">👁️</span>
        <span id="toggle-text">แสดงข้อมูลการ์ด</span>
      </button>
      
      <div class="card-info-content" id="card-info-content">
        <h3 style="text-align: center; margin-bottom: 25px; color: var(--primary);">📚 ข้อมูลการ์ดในเกม</h3>
        <div class="card-info-grid">
        <div class="card-category">
          <h4>🎴 การ์ดเซต (Set Cards)</h4>
          <div class="card-list">
            <div class="card-item" title="การ์ดขนาด 2×2 ช่อง - พื้นฐานของเกม">
              <span class="card-name">เซต 2×2</span>
              <span class="card-count">49 ใบ</span>
            </div>
            <div class="card-item" title="การ์ดขนาด 4×4 ช่อง - ทรงพลังแต่หายาก">
              <span class="card-name">เซต 4×4</span>
              <span class="card-count">4 ใบ</span>
            </div>
            <div class="card-item" title="เป้าหมาย: พื้นที่เชื่อมต่อที่เล็กที่สุดของฝั่งตรงข้าม">
              <span class="card-name">Empty Set ∅</span>
              <span class="card-count">10 ใบ</span>
            </div>
          </div>
          <div class="total-cards">
            รวมการ์ดเซต: 63 ใบ | 
            <span id="remaining-set-cards">เหลือในเด็ค: ?</span>
          </div>
        </div>

        <div class="card-category">
          <h4>⚡ การ์ดเครื่องหมาย (Marker Cards)</h4>
          <div class="card-list">
            <div class="card-item" title="รวมพื้นที่ + ยึดครองเบี้ยติดกัน (เทิร์น 16+ ห้ามใช้)">
              <span class="card-name">Union ∪</span>
              <span class="card-count">4 ใบ</span>
            </div>
            <div class="card-item" title="ได้เฉพาะพื้นที่ที่มีเบี้ยอยู่แล้วในเซต (ไม่ได้พื้นที่ว่าง)">
              <span class="card-name">Intersection ∩</span>
              <span class="card-count">12 ใบ</span>
            </div>
            <div class="card-item" title="ลบเบี้ยทั้งหมดในพื้นที่เซต (ไม่ได้พื้นที่เพิ่ม, ใช้กับเซต 1 ใบเท่านั้น)">
              <span class="card-name">Difference \</span>
              <span class="card-count">12 ใบ</span>
            </div>
            <div class="card-item" title="ทุกพื้นที่ยกเว้นการ์ดเซต (เทิร์น 10+)">
              <span class="card-name">Complement ᶜ</span>
              <span class="card-count">4 ใบ</span>
            </div>
          </div>
          <div class="total-cards">
            รวมการ์ดเครื่องหมาย: 32 ใบ | 
            <span id="remaining-marker-cards">เหลือในเด็ค: ?</span>
          </div>
        </div>
        
        <div style="margin-top: 25px; padding: 20px; background: linear-gradient(135deg, #fff7ed 0%, #fed7aa 100%); border-radius: 10px; border-left: 4px solid var(--warning);">
          <!-- กฎพิเศษถูกลบออก ไม่มีข้อจำกัดการใช้ Union/Complement ตามเทิร์น -->
        </div>
      </div>
    </div>

    <div class="game-area">
      <div class="board-section">
        <h3>🎲 กระดานเกม 8x8</h3>
        <div id="gameBoard" class="game-board"></div>
      </div>

      <div class="control-panel" role="complementary" aria-label="Game controls and information">
        <div class="score-display" role="status" aria-live="polite">
          <div class="player-score">
            <div class="chip black" aria-hidden="true">⚫</div>
            <div>
              <div>ผู้เล่นดำ</div>
              <div id="blackScore" aria-label="Black player score">0 คะแนน</div>
            </div>
          </div>
          <div class="player-score">
            <div class="chip white" aria-hidden="true">⚪</div>
            <div>
              <div>ผู้เล่นขาว</div>
              <div id="whiteScore" aria-label="White player score">0 คะแนน</div>
            </div>
          </div>
        </div>

        <div id="turnInfo" class="turn-info" role="status" aria-live="polite">
          เกมยังไม่เริ่ม
        </div>

        <div class="status-bar">
          <div id="gameStatus" role="status" aria-live="polite">กดเริ่มเกมใหม่เพื่อเล่น</div>
        </div>

        <div class="actions" role="toolbar" aria-label="Game actions">
          <button id="drawSetBtn" class="btn success" disabled aria-describedby="turnInfo">จั่วการ์ดเซต</button>
          <button id="drawMarkerBtn" class="btn secondary" disabled aria-describedby="turnInfo">จั่วการ์ดเครื่องหมาย</button>
          <button id="placeCardsBtn" class="btn primary" disabled aria-describedby="turnInfo">ลงการ์ด</button>
          <button id="discardBtn" class="btn warning" disabled aria-describedby="turnInfo">ทิ้งการ์ด</button>
          <button id="skipTurnBtn" class="btn danger" disabled aria-describedby="turnInfo">ข้าม/จบเทิร์น</button>
          <button id="newGameBtn" class="btn primary" aria-label="Start new game">เริ่มเกมใหม่</button>
        </div>

        <div class="hand">
          <h4>🃏 การ์ดในมือ</h4>
          <p style="font-size: 0.8rem; color: #666; margin-bottom: 10px;">
            💡 <strong>วิธีเล่น:</strong> 1️⃣ จั่วการ์ด → 2️⃣ เลือกใช้สิทธิ์ (ลง/ทิ้ง/ข้าม) → จบเทิร์นทันที<br>
            🎯 <strong>เครื่องหมาย:</strong> Union=รวม+ติดกัน, Intersection=ได้เฉพาะพื้นที่ที่มีเบี้ย, Difference=ลบเบี้ยทั้งหมดในเซต(ไม่ได้พื้นที่), Complement=ได้เบี้ยทั้งหมดยกเว้นในเซต!<br>
            🌟 <strong>เซตว่าง:</strong> Union=ไม่มีผล, Intersection=ลบเบี้ยทั้งสองฝ่ายทั้งหมด, Difference=ไม่มีผล, Complement=ได้เบี้ยทั้งหมดที่มีอยู่!
          </p>
          <div id="playerHand" class="cards"></div>
        </div>

        <div class="game-log">
          <h4>📋 บันทึกการเล่น</h4>
          <div id="gameLog"></div>
        </div>
      </div>
    </div>
  </div>

<script>
// ตัวแปรเกม
let gameState = {
  phase: 'waiting', // waiting, pregame, playing, finished
  turnPhase: 'draw', // draw, action
  turn: 0,
  currentPlayer: 'black', // black, white
  players: {
    black: { hand: [], score: 0, tokens: 0 },
    white: { hand: [], score: 0, tokens: 0 }
  },
  board: {},
  deckSet: [],
  deckMarker: [],
  drawnThisTurn: false,
  cardsPlacedThisTurn: { set: false, marker: false },
  selectedCards: []
};

// การ์ดเซต 2x2 (49 ใบ)
const generate2x2Cards = () => {
  const cards = [];
  const letters = ['A','B','C','D','E','F','G','H'];
  
  for(let r = 0; r < 7; r++) {
    for(let c = 0; c < 7; c++) {
      const cells = [
        `${letters[r]}${c+1}`, `${letters[r]}${c+2}`,
        `${letters[r+1]}${c+1}`, `${letters[r+1]}${c+2}`
      ];
      cards.push({
        type: 'set',
        subtype: '2x2',
        id: `2x2_${r}_${c}`,
        label: `2×2 ${letters[r]}${c+1}`,
        cells: cells
      });
    }
  }
  return cards;
};

// การ์ดเซต 4x4 (4 ใบ)
const generate4x4Cards = () => {
  const cards = [];
  const letters = ['A','B','C','D','E','F','G','H'];
  const quarters = [
    {r: 0, c: 0, name: 'Q1'}, {r: 0, c: 4, name: 'Q2'},
    {r: 4, c: 0, name: 'Q3'}, {r: 4, c: 4, name: 'Q4'}
  ];
  
  quarters.forEach(q => {
    const cells = [];
    for(let r = q.r; r < q.r + 4; r++) {
      for(let c = q.c; c < q.c + 4; c++) {
        cells.push(`${letters[r]}${c+1}`);
      }
    }
    cards.push({
      type: 'set',
      subtype: '4x4',
      id: `4x4_${q.name}`,
      label: `4×4 ${q.name}`,
      cells: cells
    });
  });
  
  return cards;
};

// การ์ดเครื่องหมาย
const generateMarkerCards = () => {
  const cards = [];
  
  // Union (4 ใบ)
  for(let i = 0; i < 4; i++) {
    cards.push({
      type: 'marker',
      subtype: 'union',
      id: `union_${i}`,
      label: 'Union (∪)'
    });
  }
  
  // Intersection (12 ใบ)
  for(let i = 0; i < 12; i++) {
    cards.push({
      type: 'marker',
      subtype: 'intersection',
      id: `intersection_${i}`,
      label: 'Intersection (∩)'
    });
  }
  
  // Difference (12 ใบ)
  for(let i = 0; i < 12; i++) {
    cards.push({
      type: 'marker',
      subtype: 'difference',
      id: `difference_${i}`,
      label: 'Difference (−)'
    });
  }
  
  // Complement (4 ใบ)
  for(let i = 0; i < 4; i++) {
    cards.push({
      type: 'marker',
      subtype: 'complement',
      id: `complement_${i}`,
      label: 'Complement (ᶜ)'
    });
  }
  
  return cards;
};

// สร้างการ์ดเซตว่าง (Empty Set)
const generateEmptySetCards = () => {
  const cards = [];
  for(let i = 0; i < 10; i++) {
    cards.push({
      type: 'set',
      subtype: 'empty',
      id: `empty_${i}`,
      label: 'Empty Set ∅',
      cells: [] // ไม่มีพื้นที่
    });
  }
  return cards;
};

// หาพื้นที่ที่เชื่อมต่อกันทั้งหมด
const getAllConnectedAreas = () => {
  const visited = new Set();
  const areas = [];
  
  for (let row = 0; row < 8; row++) {
    for (let col = 0; col < 8; col++) {
      const pos = `${String.fromCharCode(65 + row)}${col + 1}`;
      if (gameState.board[pos] && !visited.has(pos)) {
        const area = [];
        const playerColor = gameState.board[pos];
        
        const explore = (position) => {
          if (visited.has(position) || !gameState.board[position] || gameState.board[position] !== playerColor) return;
          visited.add(position);
          area.push(position);
          
          getAdjacentCells(position).forEach(adjPos => explore(adjPos));
        };
        
        explore(pos);
        if (area.length > 0) {
          areas.push({ positions: area, color: playerColor, size: area.length });
        }
      }
    }
  }
  
  return areas;
};

// หาพื้นที่เชื่อมต่อที่เล็กที่สุดของฝั่งตรงข้าม
const getSmallestOpponentArea = () => {
  const opponentColor = gameState.currentPlayer === 'black' ? 'white' : 'black';
  const allAreas = getAllConnectedAreas();
  const opponentAreas = allAreas.filter(area => area.color === opponentColor);
  
  if (opponentAreas.length === 0) return [];
  
  const smallestArea = opponentAreas.reduce((min, current) => 
    current.size < min.size ? current : min
  );
  
  return smallestArea.positions;
};

// ใช้ Empty Set กับการ์ดเครื่องหมาย
const applyEmptySetWithMarker = (emptySetCard, markerCard) => {
  console.log('🎯 Debug: applyEmptySetWithMarker called with:', emptySetCard.label, '+', markerCard.label);
  const opponentColor = gameState.currentPlayer === 'black' ? 'white' : 'black';
  const playerName = getPlayerName(gameState.currentPlayer);
  
  // หาพื้นที่ที่เชื่อมต่อกันที่เล็กที่สุดของฝั่งตรงข้าม
  const smallestOpponentArea = getSmallestOpponentArea();
  
  if (smallestOpponentArea.length === 0) {
    showAlert('ไม่มีเบี้ยของฝั่งตรงข้ามบนกระดาน!', 'warning');
    
    // ลบการ์ดแม้ไม่สำเร็จ
    const setIndex = gameState.selectedCards.find(i => gameState.players[gameState.currentPlayer].hand[i].type === 'set');
    const markerIndex = gameState.selectedCards.find(i => gameState.players[gameState.currentPlayer].hand[i].type === 'marker');
    const allIndices = [setIndex, markerIndex].sort((a, b) => b - a);
    allIndices.forEach(index => gameState.players[gameState.currentPlayer].hand.splice(index, 1));
    
    gameState.selectedCards = [];
    updateDisplay();
    return;
  }
  
  let logMsg = `${playerName} ใช้ ${emptySetCard.label} + ${markerCard.label} กับพื้นที่ ${smallestOpponentArea.length} ช่อง: ${smallestOpponentArea.join(', ')}`;
  
  switch(markerCard.subtype) {
    case 'union':
      // Union + Empty Set = ไม่เกิดอะไร
      logMsg += ' → ไม่เกิดการเปลี่ยนแปลง (Union + Empty Set)';
      break;
      
    case 'intersection':
      // Intersection + Empty Set: ลบเฉพาะเบี้ยฝ่ายตรงข้ามทั้งกระดาน
      if (!setCard.cells || setCard.cells.length === 0) {
        const opponentColor = gameState.currentPlayer === 'black' ? 'white' : 'black';
        let removed = 0;
        for (let row = 0; row < 8; row++) {
          for (let col = 0; col < 8; col++) {
            const pos = `${String.fromCharCode(65 + row)}${col + 1}`;
            if (gameState.board[pos] === opponentColor) {
              delete gameState.board[pos];
              removed++;
              const cell = document.querySelector(`[data-position="${pos}"]`);
              if(cell) {
                cell.innerHTML = pos;
                cell.style.backgroundColor = 'white';
              }
            }
          }
        }
        updateTokenCounts();
        showToast(`ลบเบี้ยฝ่ายตรงข้ามทั้งกระดาน ${removed} ช่อง (Empty Set + Intersection)`, 'success');
        resultCells = [];
        // ลบการ์ดที่ใช้ทั้งสองใบ
        const setIndex = gameState.selectedCards.find(i => gameState.players[gameState.currentPlayer].hand[i].type === 'set');
        const markerIndex = gameState.selectedCards.find(i => gameState.players[gameState.currentPlayer].hand[i].type === 'marker');
        const allIndices = [setIndex, markerIndex].sort((a, b) => b - a);
        allIndices.forEach(index => gameState.players[gameState.currentPlayer].hand.splice(index, 1));
        gameState.selectedCards = [];
        gameState.cardsPlacedThisTurn.set = true;
        gameState.cardsPlacedThisTurn.marker = true;
        updateDisplay();
        updateGameStatus('กดข้ามเทิร์นเพื่อจบเทิร์น');
        enableButtons(['skipTurnBtn']);
        return;
      } else {
        // Intersection: ได้เฉพาะพื้นที่ที่มีเบี้ยอยู่แล้ว (ทั้งสองฝ่าย)
        const existingTokensInSet = setCard.cells.filter(pos => gameState.board[pos]);
        if (existingTokensInSet.length === 0) {
          showToast('ไม่มีเบี้ยในพื้นที่เซตนี้ที่จะทำ Intersection ได้!', 'warning');
          // ลบการ์ดที่ใช้ทั้งสองใบแม้ไม่สำเร็จ
          const setIndex = gameState.selectedCards.find(i => gameState.players[gameState.currentPlayer].hand[i].type === 'set');
          const markerIndex = gameState.selectedCards.find(i => gameState.players[gameState.currentPlayer].hand[i].type === 'marker');
          const allIndices = [setIndex, markerIndex].sort((a, b) => b - a);
          allIndices.forEach(index => gameState.players[gameState.currentPlayer].hand.splice(index, 1));
          gameState.selectedCards = [];
          updateDisplay();
          return;
        }
        resultCells = existingTokensInSet;
        console.log(`Intersection: ได้พื้นที่ที่มีเบี้ยอยู่แล้ว ${resultCells.length} ช่อง: ${resultCells.join(', ')}`);
      }
      break;
      
    case 'difference':
      // Difference + Empty Set = ไม่เกิดอะไร
      logMsg += ' → ไม่เกิดการเปลี่ยนแปลง (Difference + Empty Set)';
      break;
      
    case 'complement':
      // 🔥 แก้ไข: Complement + Empty Set = ยึดครองทุกช่องบนกระดาน (64 ช่อง)
      console.log('🔥 DEBUG: Complement + Empty Set - ยึดครองทุกช่องบนกระดาน');
      
      const allCells = [];
      for (let row = 0; row < 8; row++) {
        for (let col = 0; col < 8; col++) {
          allCells.push(`${String.fromCharCode(65 + row)}${col + 1}`);
        }
      }
      
      console.log('🔥 DEBUG: Placing tokens on all', allCells.length, 'cells');
      
      allCells.forEach(pos => {
        gameState.board[pos] = gameState.currentPlayer;
        const cell = document.querySelector(`[data-position="${pos}"]`);
        if(cell) {
          const chip = document.createElement('div');
          chip.className = `chip ${gameState.currentPlayer}`;
          chip.textContent = gameState.currentPlayer === 'black' ? '⚫' : '⚪';
          cell.innerHTML = '';
          cell.appendChild(chip);
          cell.style.backgroundColor = gameState.currentPlayer === 'black' ? '#f3f4f6' : '#fef3c7';
        }
      });
      
      updateTokenCounts();
      logMsg += ` → ยึดครองทั้งกระดาน ${allCells.length} ช่อง! (Complement + Empty Set)`;
      showToast(`ยึดครองทั้งกระดาน ${allCells.length} ช่อง!`, 'success');
      break;
  }
  
  logMessage(logMsg);
  
  // ตั้งค่าสถานะ
  gameState.cardsPlacedThisTurn.set = true;
  gameState.cardsPlacedThisTurn.marker = true;
  
  // ลบการ์ดที่ใช้ทั้งสองใบ
  console.log('🔥 DEBUG: [EmptySet] About to remove cards from hand');
  console.log('🔥 DEBUG: [EmptySet] Current hand size:', gameState.players[gameState.currentPlayer].hand.length);
  console.log('🔥 DEBUG: [EmptySet] Selected cards:', gameState.selectedCards);
  
  const setIndex = gameState.selectedCards.find(i => gameState.players[gameState.currentPlayer].hand[i].type === 'set');
  const markerIndex = gameState.selectedCards.find(i => gameState.players[gameState.currentPlayer].hand[i].type === 'marker');
  
  console.log('🔥 DEBUG: [EmptySet] Found setIndex:', setIndex);
  console.log('🔥 DEBUG: [EmptySet] Found markerIndex:', markerIndex);
  
  if (setIndex === undefined || markerIndex === undefined) {
    console.error('🔥 DEBUG: [EmptySet] Cannot find card indices!');
    console.log('🔥 DEBUG: [EmptySet] Hand contents:', gameState.players[gameState.currentPlayer].hand.map(card => `${card.type}-${card.label}`));
    return;
  }
  
  const allIndices = [setIndex, markerIndex].sort((a, b) => b - a);
  console.log('🔥 DEBUG: [EmptySet] Removing cards at indices:', allIndices);
  
  allIndices.forEach(index => {
    const card = gameState.players[gameState.currentPlayer].hand[index];
    if (card) {
      console.log('🔥 DEBUG: [EmptySet] Removing card:', card.label, 'at index', index);
      gameState.players[gameState.currentPlayer].hand.splice(index, 1);
    } else {
      console.error('🔥 DEBUG: [EmptySet] No card found at index', index);
    }
  });
  
  console.log('🔥 DEBUG: [EmptySet] Hand size after removal:', gameState.players[gameState.currentPlayer].hand.length);
  
  gameState.selectedCards = [];
  updateDisplay();
  
  // จบเทิร์นทันที
  setTimeout(() => {
    skipTurn();
  }, 1000);
  updateGameStatus('ใช้ Empty Set แล้ว - จะจบเทิร์นในอีก 1 วินาที...');
  enableButtons([]);
};

// สร้างกระดาน
const createBoard = () => {
  const board = document.getElementById('gameBoard');
  board.innerHTML = '';
  
  const letters = ['A','B','C','D','E','F','G','H'];
  const numbers = ['1','2','3','4','5','6','7','8'];
  
  // มุมซ้ายบน
  const cornerCell = document.createElement('div');
  cornerCell.className = 'cell header';
  cornerCell.textContent = '🎯';
  board.appendChild(cornerCell);
  
  // หัวคอลัมน์
  numbers.forEach(num => {
    const cell = document.createElement('div');
    cell.className = 'cell header';
    cell.textContent = num;
    board.appendChild(cell);
  });
  
  // แถวและเซลล์เกม
  letters.forEach(letter => {
    // หัวแถว
    const rowHeader = document.createElement('div');
    rowHeader.className = 'cell header';
    rowHeader.textContent = letter;
    board.appendChild(rowHeader);
    
    // เซลล์เกม
    numbers.forEach(num => {
      const cell = document.createElement('div');
      cell.className = 'cell game-cell';
      cell.dataset.position = `${letter}${num}`;
      cell.textContent = `${letter}${num}`;
      board.appendChild(cell);
    });
  });
};

// สุ่มการ์ด
const shuffleArray = (array) => {
  const newArray = [...array];
  for (let i = newArray.length - 1; i > 0; i--) {
    const j = Math.floor(Math.random() * (i + 1));
    [newArray[i], newArray[j]] = [newArray[j], newArray[i]];
  }
  return newArray;
};

// หาช่องที่อยู่ติดกัน
const getAdjacentCells = (position) => {
  const letter = position.charAt(0);
  const number = parseInt(position.charAt(1));
  const adjacent = [];
  
  // ขึ้น, ลง, ซ้าย, ขวา
  const directions = [
    { row: -1, col: 0 }, // ขึ้น
    { row: 1, col: 0 },  // ลง
    { row: 0, col: -1 }, // ซ้าย
    { row: 0, col: 1 }   // ขวา
  ];
  
  const letterIndex = letter.charCodeAt(0) - 65; // A=0, B=1, ...
  
  directions.forEach(dir => {
    const newRow = letterIndex + dir.row;
    const newCol = number - 1 + dir.col; // number เป็น 1-based
    
    if (newRow >= 0 && newRow <= 7 && newCol >= 0 && newCol <= 7) {
      const newLetter = String.fromCharCode(65 + newRow);
      const newNumber = newCol + 1;
      adjacent.push(`${newLetter}${newNumber}`);
    }
  });
  
  return adjacent;
};

// หาพื้นที่ที่เชื่อมต่อกัน (Connected Components)
const getConnectedArea = (startPositions, playerColor) => {
  const visited = new Set();
  const connectedArea = new Set();
  
  const dfs = (position) => {
    if (visited.has(position) || connectedArea.has(position)) return;
    
    // ตรวจสอบว่าช่องนี้มีเบี้ยของผู้เล่นหรือไม่
    if (!gameState.board[position] || gameState.board[position] !== playerColor) {
      return;
    }
    
    visited.add(position);
    connectedArea.add(position);
    
    // ค้นหาช่องติดกันที่มีเบี้ยสีเดียวกัน
    const adjacent = getAdjacentCells(position);
    adjacent.forEach(adjPos => {
      if (gameState.board[adjPos] === playerColor) {
        dfs(adjPos);
      }
    });
  };
  
  // เริ่มค้นหาจากทุกตำแหน่งเริ่มต้น
  startPositions.forEach(pos => {
    if (gameState.board[pos] === playerColor) {
      dfs(pos);
    }
  });
  
  return Array.from(connectedArea);
};

// เริ่มเกมใหม่

// ฟังก์ชันเปลี่ยนการ์ดจากกอง (สำหรับ pregame phase)
const changeCardFromDeck = () => {
  const cardIndex = gameState.selectedCards[0];
  const oldCard = gameState.players[gameState.currentPlayer].hand[cardIndex];
  
  // ใส่การ์ดเก่ากลับไปที่ด้านล่างของกอง
  gameState.deckSet.unshift(oldCard);
  
  // จั่วการ์ดใหม่จากด้านบน
  if(gameState.deckSet.length > 1) {
    const newCard = gameState.deckSet.pop();
    gameState.players[gameState.currentPlayer].hand[cardIndex] = newCard;
    
    const playerName = getPlayerName(gameState.currentPlayer);
    logMessage(`${playerName} เปลี่ยนการ์ด: ${oldCard.label} → ${newCard.label} (หลีกเลี่ยงการซ้ำ)`);
    
    // ตรวจสอบการ์ดใหม่ว่าซ้ำหรือไม่
    const conflicts = newCard.cells.filter(pos => gameState.board[pos]);
    if(conflicts.length > 0) {
      // ยังซ้ำอยู่ ให้เปลี่ยนอีกครั้ง
      // ผู้เล่นคนเลือก
      const continueChange = confirm(`การ์ดใหม่ยังซ้ำกับผู้เล่นแรกอยู่ที่: ${conflicts.join(', ')}\n\nต้องการเปลี่ยนการ์ดใหม่อีกครั้งหรือไม่?`);
      
      if(continueChange && gameState.deckSet.length > 1) {
        changeCardFromDeck();
        return;
      } else {
        // ให้เลือกการ์ดอื่นจากมือ
        showAlert('กรุณาเลือกการ์ดอื่นจากมือ หรือเปลี่ยนการ์ดใหม่อีกครั้ง', 'info');
        gameState.selectedCards = [];
        updateDisplay();
        return;
      }
    } else {
      // การ์ดใหม่ไม่ซ้ำ ใช้ได้
      gameState.selectedCards = [cardIndex];
      updateDisplay();
      
      // แสดงข้อความแนะนำสำหรับผู้เล่น
      updateGameStatus('การ์ดใหม่ไม่ซ้ำแล้ว - กดวางการ์ดเพื่อดำเนินการต่อ');
      enableButtons(['placeCardsBtn']);
    }
  } else {
    showAlert('ไม่มีการ์ดในกองให้เปลี่ยน!', 'warning');
  }
};

// ฟังก์ชันสำหรับแสดงชื่อผู้เล่น
const getPlayerName = (color) => {
  return color === 'black' ? 'ผู้เล่น 1 (ดำ)' : 'ผู้เล่น 2 (ขาว)';
};

const startNewGame = () => {
  console.log('🎮 Debug: startNewGame called');
  
  // เริ่มเกมโหมด 2 ผู้เล่นโดยตรง
  gameState = {
    phase: 'pregame',
    turn: 0,
    currentPlayer: 'black',
    players: {
      black: { hand: [], score: 0, tokens: 0 },
      white: { hand: [], score: 0, tokens: 0 }
    },
    board: {},
    deckSet: shuffleArray([...generate2x2Cards(), ...generate4x4Cards(), ...generateEmptySetCards()]),
    deckMarker: shuffleArray(generateMarkerCards()),
    drawnThisTurn: false,
    cardsPlacedThisTurn: { set: false, marker: false },
    selectedCards: []
  };
  
  // แจกการ์ดเริ่มต้น (การ์ดเซตคนละ 2 ใบ)
  for(let i = 0; i < 2; i++) {
    gameState.players.black.hand.push(gameState.deckSet.pop());
    gameState.players.white.hand.push(gameState.deckSet.pop());
  }
  
  clearBoard();
  updateDisplay();
  
  logMessage('🎮 เริ่มเกมใหม่! ผู้เล่น 1 (ดำ) vs ผู้เล่น 2 (ขาว)');
  logMessage('📝 ให้ผู้เล่นดำลงการ์ดเซต 1 ใบก่อน (ต้องไม่ซ้ำกับผู้เล่นขาว)');
  
  updateGameStatus('ผู้เล่น 1 (ดำ): เลือกการ์ดเซต 1 ใบเพื่อวางเบี้ยเริ่มต้น');
  enableButtons(['placeCardsBtn']);
};

// ล้างกระดาน
const clearBoard = () => {
  gameState.board = {};
  const cells = document.querySelectorAll('.game-cell');
  cells.forEach(cell => {
    cell.innerHTML = cell.dataset.position;
    cell.style.backgroundColor = 'white';
  });
};

// วางเบี้ยบนกระดาน
const placeTokens = (positions, player) => {
  console.log(`Placing tokens for ${player} at positions:`, positions);
  
  try {
    positions.forEach(pos => {
      gameState.board[pos] = player;
      const cell = document.querySelector(`[data-position="${pos}"]`);
      if(cell) {
        const chip = document.createElement('div');
        chip.className = `chip ${player}`;
        chip.textContent = player === 'black' ? '⚫' : '⚪';
        cell.innerHTML = '';
        cell.appendChild(chip);
        
        // เพิ่มสีพื้นหลังเล็กน้อยเพื่อแสดงการครอบครอง
        cell.style.backgroundColor = player === 'black' ? '#f3f4f6' : '#fef3c7';
      } else {
        console.error(`Cannot find cell for position: ${pos}`);
        throw new Error(`ไม่พบช่องที่ตำแหน่ง ${pos}`);
      }
    });
    updateTokenCounts();
    console.log(`Successfully placed ${positions.length} tokens for ${player}`);
  } catch (error) {
    console.error('Error in placeTokens:', error);
    throw error; // Re-throw เพื่อให้ caller จัดการต่อ
  }
};

// นับจำนวนเบี้ย
const updateTokenCounts = () => {
  gameState.players.black.tokens = Object.values(gameState.board).filter(p => p === 'black').length;
  gameState.players.white.tokens = Object.values(gameState.board).filter(p => p === 'white').length;
};

// คำนวณคะแนน
const calculateScore = (player) => {
  return gameState.players[player].tokens - gameState.players[player].hand.length;
};

// อัพเดทการแสดงผล
const updateDisplay = () => {
  // อัพเดทคะแนน
  document.getElementById('blackScore').textContent = `${calculateScore('black')} คะแนน (เบี้ย: ${gameState.players.black.tokens}, การ์ด: ${gameState.players.black.hand.length})`;
  document.getElementById('whiteScore').textContent = `${calculateScore('white')} คะแนน (เบี้ย: ${gameState.players.white.tokens}, การ์ด: ${gameState.players.white.hand.length})`;
  
  // อัพเดทข้อมูลเทิร์น
  const turnInfo = document.getElementById('turnInfo');
  turnInfo.className = 'turn-info'; // รีเซ็ต class
  
  if(gameState.phase === 'playing') {
    const playerName = gameState.currentPlayer === 'black' ? 'ผู้เล่นดำ' : 'ผู้เล่นขาว';
    const playerIcon = gameState.currentPlayer === 'black' ? '⚫' : '⚪';
    turnInfo.className = `turn-info ${gameState.currentPlayer}-turn active`;
    turnInfo.innerHTML = `
      <div class="current-player-indicator">
        <span>${playerIcon}</span>
        <span>เทิร์นที่ ${gameState.turn}/20 - ${playerName}</span>
      </div>
    `;
  } else if(gameState.phase === 'pregame') {
    const playerName = gameState.currentPlayer === 'black' ? 'ผู้เล่นดำ' : 'ผู้เล่นขาว';
    const playerIcon = gameState.currentPlayer === 'black' ? '⚫' : '⚪';
    turnInfo.className = `turn-info ${gameState.currentPlayer}-turn active`;
    turnInfo.innerHTML = `
      <div class="current-player-indicator">
        <span>${playerIcon}</span>
        <span>เตรียมเริ่มเกม - ${playerName} วางเบี้ยเริ่มต้น</span>
      </div>
    `;
  } else if(gameState.phase === 'finished') {
    const blackScore = calculateScore('black');
    const whiteScore = calculateScore('white');
    const winner = blackScore > whiteScore ? 'ผู้เล่นดำ' : blackScore < whiteScore ? 'ผู้เล่นขาว' : 'เสมอ';
    turnInfo.className = 'turn-info';
    turnInfo.textContent = `🏁 จบเกม! ผู้ชนะ: ${winner}`;
  } else {
    turnInfo.className = 'turn-info';
    turnInfo.textContent = 'กดเริ่มเกมใหม่เพื่อเล่น';
  }
  
  // อัพเดทการ์ดในมือ
  updatePlayerHand();
  
  // อัพเดทการนับการ์ดคงเหลือ
  updateCardCounts();
};

// แสดงการ์ดในมือ
const updatePlayerHand = () => {
  const handDiv = document.getElementById('playerHand');
  handDiv.innerHTML = '';
  
  if(gameState.phase === 'waiting') return;
  
  const currentHand = gameState.players[gameState.currentPlayer].hand;
  currentHand.forEach((card, index) => {
    const cardElement = document.createElement('div');
    cardElement.className = `card ${card.type}`;
    cardElement.onclick = () => selectCard(index);
    
    // สร้างข้อความหลัก
    const labelDiv = document.createElement('div');
    labelDiv.textContent = card.label;
    cardElement.appendChild(labelDiv);
    
    // แสดงรายละเอียดพื้นที่สำหรับการ์ดเซต
    if(card.type === 'set' && card.cells) {
      const detailsDiv = document.createElement('div');
      detailsDiv.className = 'card-details';
      detailsDiv.textContent = `พื้นที่: ${card.cells.join(', ')}`;
      cardElement.appendChild(detailsDiv);
    }
    
    cardElement.dataset.index = index;
    
    if(gameState.selectedCards.includes(index)) {
      cardElement.classList.add('selected');
    }
    
    handDiv.appendChild(cardElement);
  });
};

// เลือกการ์ด
const selectCard = (index) => {
  console.log('👤 DEBUG: [HUMAN] selectCard called with index:', index);
  console.log('👤 DEBUG: [HUMAN] Current selectedCards before:', [...gameState.selectedCards]);
  console.log('👤 DEBUG: [HUMAN] Current player:', gameState.currentPlayer);
  console.log('👤 DEBUG: [HUMAN] Game phase:', gameState.phase, 'Turn phase:', gameState.turnPhase);
  
  const cardIndex = gameState.selectedCards.indexOf(index);
  if(cardIndex === -1) {
    gameState.selectedCards.push(index);
    console.log('👤 DEBUG: [HUMAN] Added card index', index, 'to selection');
  } else {
    gameState.selectedCards.splice(cardIndex, 1);
    console.log('👤 DEBUG: [HUMAN] Removed card index', index, 'from selection');
  }
  
  console.log('👤 DEBUG: [HUMAN] selectedCards after:', [...gameState.selectedCards]);
  console.log('👤 DEBUG: [HUMAN] Selected cards count:', gameState.selectedCards.length);
  updatePlayerHand();
};

// เปิด/ปิดปุ่ม
const enableButtons = (buttons) => {
  const allButtons = ['drawSetBtn', 'drawMarkerBtn', 'placeCardsBtn', 'discardBtn', 'skipTurnBtn'];
  allButtons.forEach(id => {
    const btn = document.getElementById(id);
    if (btn) {
      btn.disabled = !buttons.includes(id);
      // ปิด loading state ถ้ามี
      if (btn.classList.contains('loading')) {
        btn.classList.remove('loading');
      }
    }
  });
  
  // Debug: log สถานะปุ่ม
  console.log('🎮 Debug: enableButtons called with:', buttons, 'Phase:', gameState.phase, 'TurnPhase:', gameState.turnPhase);
};

// อัพเดทสถานะเกม
const updateGameStatus = (message) => {
  document.getElementById('gameStatus').textContent = message;
};

// บันทึกข้อความ
const logMessage = (message) => {
  const logDiv = document.getElementById('gameLog');
  const entry = document.createElement('div');
  entry.className = 'log-entry';
  entry.textContent = message;
  logDiv.appendChild(entry);
  logDiv.scrollTop = logDiv.scrollHeight;
};

// จั่วการ์ดเซต
const drawSetCard = () => {
  if(gameState.drawnThisTurn) {
    alert('คุณได้จั่วการ์ดในเทิร์นนี้แล้ว!');
    return;
  }
  
  if(gameState.deckSet.length === 0) {
    alert('กองการ์ดเซตหมดแล้ว!');
    return;
  }
  
  const card = gameState.deckSet.pop();
  gameState.players[gameState.currentPlayer].hand.push(card);
  
  const playerName = getPlayerName(gameState.currentPlayer);
  logMessage(`${playerName} จั่วการ์ดเซต: ${card.label} (${card.cells.join(', ')})`);
  
  // จั่วการ์ดแล้วเข้าสู่ขั้นตอนเลือกใช้สิทธิ์
  gameState.drawnThisTurn = true;
  gameState.turnPhase = 'action';
  updateDisplay();
  
  updateGameStatus('เลือกใช้สิทธิ์: ลงการ์ด (สูงสุด 2 ใบ ประเภทละ 1 ใบ), ทิ้งการ์ด (1 ใบ), หรือข้ามเทิร์น');
  enableButtons(['placeCardsBtn', 'discardBtn', 'skipTurnBtn']);
};

// จั่วการ์ดเครื่องหมาย
const drawMarkerCard = () => {
  if(gameState.drawnThisTurn) {
    alert('คุณได้จั่วการ์ดในเทิร์นนี้แล้ว!');
    return;
  }
  
  if(gameState.deckMarker.length === 0) {
    alert('กองการ์ดเครื่องหมายหมดแล้ว!');
    return;
  }
  
  let card = gameState.deckMarker.pop();
  
  // ตรวจสอบกฎเทิร์นที่ 16+ สำหรับ Union
  // ไม่มีข้อจำกัดการใช้ Union
  
  // ตรวจสอบกฎ Complement (ใช้ได้ตั้งแต่เทิร์นที่ 10)
  // ไม่มีข้อจำกัดการใช้ Complement
    // ตรวจสอบซ้ำถ้าการ์ดใหม่ยังเป็น Complement
    if(card.subtype === 'complement' && gameState.turn < 10) {
  // ไม่มีข้อจำกัดการใช้ Complement
  }
  
  gameState.players[gameState.currentPlayer].hand.push(card);
  
  const playerName = getPlayerName(gameState.currentPlayer);
  logMessage(`${playerName} จั่วการ์ดเครื่องหมาย: ${card.label}`);
  
  // จั่วการ์ดแล้วเข้าสู่ขั้นตอนเลือกใช้สิทธิ์
  gameState.drawnThisTurn = true;
  gameState.turnPhase = 'action';
  updateDisplay();
  
  updateGameStatus('เลือกใช้สิทธิ์: ลงการ์ด (สูงสุด 2 ใบ ประเภทละ 1 ใบ), ทิ้งการ์ด (1 ใบ), หรือข้ามเทิร์น');
  enableButtons(['placeCardsBtn', 'discardBtn', 'skipTurnBtn']);
};

// ลงการ์ด
const placeCards = () => {
  console.log('👤 DEBUG: [HUMAN] placeCards called');
  console.log('👤 DEBUG: [HUMAN] Current phase:', gameState.phase, 'Turn phase:', gameState.turnPhase);
  console.log('👤 DEBUG: [HUMAN] Selected cards:', [...gameState.selectedCards]);
  console.log('👤 DEBUG: [HUMAN] Cards placed this turn:', gameState.cardsPlacedThisTurn);
  console.log('👤 DEBUG: [HUMAN] Current player:', gameState.currentPlayer);
  
  console.log('🎮 Debug: placeCards called, phase:', gameState.phase);
  if(gameState.phase === 'pregame') {
    console.log('👤 DEBUG: [HUMAN] Pregame mode - calling placePregameCard');
    placePregameCard();
    return;
  }
  
  if(gameState.turnPhase !== 'action') {
    console.log('👤 DEBUG: [HUMAN] Wrong turn phase - expected action, got:', gameState.turnPhase);
    alert('ต้องจั่วการ์ดก่อนลงการ์ด!');
    return;
  }
  
  if(gameState.selectedCards.length === 0) {
    console.log('👤 DEBUG: [HUMAN] No cards selected');
    alert('เลือกการ์ดที่ต้องการลงก่อน!');
    return;
  }
  
  if(gameState.selectedCards.length > 2) {
    console.log('👤 DEBUG: [HUMAN] Too many cards selected:', gameState.selectedCards.length);
    alert('ลงได้สูงสุด 2 ใบ (ประเภทละ 1 ใบ)!');
    return;
  }
  
  // ตรวจสอบประเภทการ์ด
  const selectedCardObjs = gameState.selectedCards.map(i => gameState.players[gameState.currentPlayer].hand[i]);
  const setCards = selectedCardObjs.filter(c => c.type === 'set');
  const markerCards = selectedCardObjs.filter(c => c.type === 'marker');
  
  console.log('👤 DEBUG: [HUMAN] Card type analysis:');
  console.log('👤 DEBUG: [HUMAN] - Set cards:', setCards.length, setCards.map(c => c.label));
  console.log('👤 DEBUG: [HUMAN] - Marker cards:', markerCards.length, markerCards.map(c => c.label));
  
  if(setCards.length > 1 || markerCards.length > 1) {
    console.log('👤 DEBUG: [HUMAN] Multiple cards of same type selected');
    alert('ลงได้ประเภทละ 1 ใบเท่านั้น!');
    return;
  }
  
  // ตรวจสอบว่าลงประเภทนี้แล้วหรือยัง
  if(setCards.length > 0 && gameState.cardsPlacedThisTurn.set) {
    console.log('👤 DEBUG: [HUMAN] Set card already placed this turn');
    alert('ลงการ์ดเซตไปแล้วในเทิร์นนี้!');
    return;
  }
  
  if(markerCards.length > 0 && gameState.cardsPlacedThisTurn.marker) {
    console.log('👤 DEBUG: [HUMAN] Marker card already placed this turn');
    alert('ลงการ์ดเครื่องหมายไปแล้วในเทิร์นนี้!');
    return;
  }
  
  // ลงการ์ดเซต
  if(setCards.length > 0) {
    console.log('👤 DEBUG: [HUMAN] Processing set card placement');
    const setCard = setCards[0];
    
    // จัดการ Empty Set (เซตว่าง)
    if(setCard.subtype === 'empty') {
      console.log('🔥 Debug: Empty Set detected:', setCard.label);
      if(markerCards.length === 0) {
        alert('Empty Set ต้องใช้ร่วมกับการ์ดเครื่องหมาย!');
        return;
      }
      
      const markerCard = markerCards[0];
      console.log('🔥 Debug: Using Empty Set with marker:', markerCard.label);
      applyEmptySetWithMarker(setCard, markerCard);
      return; // applyEmptySetWithMarker จัดการลบการ์ดและ update เองแล้ว
    }
    
    // ตรวจสอบการทับซ้อนทั้งหมด (ทั้งฝั่งตรงข้ามและตัวเอง)
    const conflicts = setCard.cells.filter(pos => gameState.board[pos] && gameState.board[pos] !== gameState.currentPlayer);
    const ownTokens = setCard.cells.filter(pos => gameState.board[pos] === gameState.currentPlayer);
    
    // ถ้ามีการ์ดเครื่องหมาย แสดงว่าผู้เล่นต้องการใช้ operation พิเศษ
    if(markerCards.length > 0) {
      const markerCard = markerCards[0];
      // Union สามารถลงทับเบี้ยตัวเองและฝั่งตรงข้ามได้
      applySetWithMarker(setCard, markerCard, conflicts);
      return; // applySetWithMarker จัดการลบการ์ดและ update เองแล้ว
    } 
    // ถ้ามีการทับซ้อนกับฝั่งตรงข้าม ต้องใช้การ์ดเครื่องหมายควบคู่
    else if(conflicts.length > 0) {
      alert(`การ์ดเซตทับซ้อนกับเบี้ยฝั่งตรงข้ามที่: ${conflicts.join(', ')}\nต้องเลือกการ์ดเครื่องหมายควบคู่เพื่อใช้งาน!`);
      return;
    }
    // ถ้าทับซ้อนกับเบี้ยตัวเอง แจ้งเตือน
    else if(ownTokens.length > 0) {
      alert(`การ์ดเซตทับซ้อนกับเบี้ยของตัวเองที่: ${ownTokens.join(', ')}\nไม่สามารถลงทับได้!`);
      return;
    }
    else {
      // ลงการ์ดเซตปกติ (ไม่มีการทับซ้อน)
      try {
        placeTokens(setCard.cells, gameState.currentPlayer);
        gameState.cardsPlacedThisTurn.set = true;
        
        const playerName = gameState.currentPlayer === 'black' ? 'ผู้เล่นดำ' : 'ผู้เล่นขาว';
        logMessage(`${playerName} ลงการ์ดเซต: ${setCard.label}`);
      } catch (error) {
        console.error('Error placing set card:', error);
        alert('เกิดข้อผิดพลาดในการลงการ์ดเซต: ' + error.message);
        return;
      }
    }
  }
  
  // ลงการ์ดเครื่องหมายโดยลำพัง (ต้องมีการ์ดเซต 2 ใบ)
  if(markerCards.length > 0 && setCards.length === 0) {
    const markerCard = markerCards[0];
    
    // ในเกมนี้ไม่สามารถใช้การ์ดเครื่องหมายกับการ์ดเซต 2 ใบได้
    alert('ในเกมนี้ใช้การ์ดเครื่องหมายกับการ์ดเซต 1 ใบเท่านั้น!');
    return;
  }
  
  // ลบการ์ดที่ลงแล้วออกจากมือ
  console.log('🔥 DEBUG: [Normal] About to remove cards from hand');
  console.log('🔥 DEBUG: [Normal] Current hand size:', gameState.players[gameState.currentPlayer].hand.length);
  console.log('🔥 DEBUG: [Normal] Selected cards:', gameState.selectedCards);
  
  gameState.selectedCards.sort((a, b) => b - a).forEach(index => {
    const card = gameState.players[gameState.currentPlayer].hand[index];
    if (card) {
      console.log('🔥 DEBUG: [Normal] Removing card:', card.label, 'at index', index);
      gameState.players[gameState.currentPlayer].hand.splice(index, 1);
    } else {
      console.error('🔥 DEBUG: [Normal] No card found at index', index);
    }
  });
  
  console.log('🔥 DEBUG: [Normal] Hand size after removal:', gameState.players[gameState.currentPlayer].hand.length);
  
  gameState.selectedCards = [];
  updateDisplay();
  
  // ตรวจสอบว่าสามารถลงการ์ดเพิ่มได้หรือไม่
  const canPlaceMore = (!gameState.cardsPlacedThisTurn.set || !gameState.cardsPlacedThisTurn.marker) &&
                      gameState.players[gameState.currentPlayer].hand.length > 0;
  
  if(canPlaceMore) {
    updateGameStatus('สามารถลงการ์ดเพิ่มได้ (ประเภทละ 1 ใบ) หรือเลือกทิ้งการ์ด/ข้ามเทิร์น');
    enableButtons(['placeCardsBtn', 'discardBtn', 'skipTurnBtn']);
  } else {
    // จบเทิร์นเมื่อลงการ์ดครบแล้ว
    // ผู้เล่นต้องกดจบเทิร์นเอง
    updateGameStatus('ลงการ์ดครบแล้ว - กดข้าม/จบเทิร์น เพื่อจบเทิร์น');
    enableButtons(['skipTurnBtn']);
  }
};

// วางการ์ดก่อนเริ่มเกม
const placePregameCard = () => {
  console.log('🎮 Debug: placePregameCard called');
  if(gameState.selectedCards.length !== 1) {
    alert('เลือกการ์ดเซต 1 ใบ!');
    return;
  }
  
  const cardIndex = gameState.selectedCards[0];
  const card = gameState.players[gameState.currentPlayer].hand[cardIndex];
  console.log('🎮 Debug: Current player:', gameState.currentPlayer, 'Card:', card.label);
  
  if(card.type !== 'set') {
    alert('ต้องเลือกการ์ดเซตเท่านั้น!');
    return;
  }
  
  // ตรวจสอบการทับซ้อน (สำหรับผู้เล่นคนที่สอง)
  if(gameState.currentPlayer === 'white') {
    const conflicts = card.cells.filter(pos => gameState.board[pos]);
    console.log('🎮 Debug: Checking conflicts for white player:', conflicts);
    if(conflicts.length > 0) {
      console.log('🎮 Debug: Conflicts found, showing dialog');
      // เสนอให้เปลี่ยนการ์ด
      const changeCard = confirm(`การ์ดทับซ้อนกับผู้เล่นแรกที่: ${conflicts.join(', ')}\n\nต้องการเปลี่ยนการ์ดใหม่หรือไม่?\n(OK = เปลี่ยนการ์ด, Cancel = เลือกการ์ดอื่นจากมือ)`);
      
      if(changeCard) {
        console.log('🎮 Debug: User chose to change card from deck');
        // เปลี่ยนการ์ดใหม่จากกอง
        changeCardFromDeck();
        return;
      } else {
        console.log('🎮 Debug: User chose to select different card from hand');
        // ให้เลือกการ์ดอื่นจากมือ
        gameState.selectedCards = [];
        updateDisplay();
        return;
      }
    }
  }
  
  placeTokens(card.cells, gameState.currentPlayer);
  gameState.players[gameState.currentPlayer].hand.splice(cardIndex, 1);
  gameState.selectedCards = [];
  
  const playerName = gameState.currentPlayer === 'black' ? 'ผู้เล่นดำ' : 'ผู้เล่นขาว';
  logMessage(`${playerName} วางการ์ดเซตเริ่มต้น: ${card.label}`);
  
  if(gameState.currentPlayer === 'black') {
    gameState.currentPlayer = 'white';
    updateDisplay();
    
    updateGameStatus('ผู้เล่นขาว: เลือกการ์ดเซต 1 ใบเพื่อวางเบี้ยเริ่มต้น (ต้องไม่ทับกับผู้เล่นดำ)');
    enableButtons(['placeCardsBtn']);
  } else {
    // เริ่มเกมจริง
    gameState.phase = 'playing';
    gameState.turn = 1;
    gameState.turnPhase = 'draw';
    gameState.currentPlayer = 'black';
    gameState.drawnThisTurn = false;
    gameState.cardsPlacedThisTurn = { set: false, marker: false };
    
    logMessage('🎯 เริ่มเกมจริง! เทิร์นที่ 1 - ผู้เล่นดำ');
    updateDisplay();
    
    updateGameStatus('ผู้เล่นดำ: จั่วการ์ด 1 ใบก่อน');
    enableButtons(['drawSetBtn', 'drawMarkerBtn']);
  }
};

// แสดง Modal เลือกการ์ดเซต
// ใช้การ์ดเซตกับเครื่องหมายควบคู่ (เมื่อมีการทับซ้อน)
const applySetWithMarker = (setCard, markerCard, conflicts) => {
  let resultCells = [];
  const opponentColor = gameState.currentPlayer === 'black' ? 'white' : 'black';
  
  console.log(`Applying ${markerCard.subtype} with set:`, setCard.cells, 'conflicts:', conflicts);
  
  switch(markerCard.subtype) {
    case 'union':
      // ตรวจสอบการ์ดเซตว่าง (ไม่มี cells หรือ cells เป็น array ว่าง)
      if (!setCard.cells || setCard.cells.length === 0) {
        // 2.1.1 เซตใด ๆ ยูเนียนกับเซตว่าง: ไม่เกิดผลใด ๆ กับสมาชิกที่อยู่บนกระดาน
        console.log('Union with empty set: No effect on board');
        resultCells = [];
      } else {
        // Union: ยึดครองพื้นที่ทั้งหมดของการ์ดเซต + พื้นที่ที่เชื่อมต่อกันของฝั่งตรงข้าม
        resultCells = [...setCard.cells];
        console.log('Union: Starting with set cells:', resultCells);
        
        // หาพื้นที่ที่เชื่อมต่อกันของฝั่งตรงข้ามที่ติดกับพื้นที่ใหม่
        // หาพื้นที่ที่เชื่อมต่อกันของฝั่งตรงข้ามที่ติดกับพื้นที่ใหม่
        const adjacentOpponentTokens = new Set();
        setCard.cells.forEach(pos => {
          const adjacent = getAdjacentCells(pos);
          adjacent.forEach(adjPos => {
            if (gameState.board[adjPos] === opponentColor) {
              adjacentOpponentTokens.add(adjPos);
            }
          });
        });
        console.log('Union: Adjacent opponent tokens:', Array.from(adjacentOpponentTokens));
        
        // หาพื้นที่ที่เชื่อมต่อกันทั้งหมดของฝั่งตรงข้าม
        if (adjacentOpponentTokens.size > 0) {
          const connectedOpponentArea = getConnectedArea(Array.from(adjacentOpponentTokens), opponentColor);
          console.log('Union: Connected opponent area:', connectedOpponentArea);
          resultCells = [...resultCells, ...connectedOpponentArea];
        }
        
        // ลบค่าซ้ำ
        resultCells = [...new Set(resultCells)];
        console.log('Union: Final result cells:', resultCells);
        
        if (resultCells.length === 0) {
          console.error('Union resulted in 0 cells!');
          throw new Error('การดำเนินการ Union ไม่ได้ผลลัพธ์');
        }
      }
      break;
      
    case 'intersection':
      // Intersection + Empty Set: ลบเฉพาะเบี้ยฝ่ายตรงข้ามทั้งกระดาน
      if (!setCard.cells || setCard.cells.length === 0) {
        const opponentColor = gameState.currentPlayer === 'black' ? 'white' : 'black';
        let removed = 0;
        for (let row = 0; row < 8; row++) {
          for (let col = 0; col < 8; col++) {
            const pos = `${String.fromCharCode(65 + row)}${col + 1}`;
            if (gameState.board[pos] === opponentColor) {
              delete gameState.board[pos];
              removed++;
              const cell = document.querySelector(`[data-position="${pos}"]`);
              if(cell) {
                cell.innerHTML = pos;
                cell.style.backgroundColor = 'white';
              }
            }
          }
        }
        updateTokenCounts();
        showToast(`ลบเบี้ยฝ่ายตรงข้ามทั้งกระดาน ${removed} ช่อง (Empty Set + Intersection)`, 'success');
        resultCells = [];
        // ลบการ์ดที่ใช้ทั้งสองใบ
        const setIndex = gameState.selectedCards.find(i => gameState.players[gameState.currentPlayer].hand[i].type === 'set');
        const markerIndex = gameState.selectedCards.find(i => gameState.players[gameState.currentPlayer].hand[i].type === 'marker');
        const allIndices = [setIndex, markerIndex].sort((a, b) => b - a);
        allIndices.forEach(index => gameState.players[gameState.currentPlayer].hand.splice(index, 1));
        gameState.selectedCards = [];
        gameState.cardsPlacedThisTurn.set = true;
        gameState.cardsPlacedThisTurn.marker = true;
        updateDisplay();
        updateGameStatus('กดข้ามเทิร์นเพื่อจบเทิร์น');
        enableButtons(['skipTurnBtn']);
        return;
      } else {
        // Intersection: ได้เฉพาะพื้นที่ที่มีเบี้ยอยู่แล้ว (ทั้งสองฝ่าย)
        const existingTokensInSet = setCard.cells.filter(pos => gameState.board[pos]);
        if (existingTokensInSet.length === 0) {
          showToast('ไม่มีเบี้ยในพื้นที่เซตนี้ที่จะทำ Intersection ได้!', 'warning');
          // ลบการ์ดที่ใช้ทั้งสองใบแม้ไม่สำเร็จ
          const setIndex = gameState.selectedCards.find(i => gameState.players[gameState.currentPlayer].hand[i].type === 'set');
          const markerIndex = gameState.selectedCards.find(i => gameState.players[gameState.currentPlayer].hand[i].type === 'marker');
          const allIndices = [setIndex, markerIndex].sort((a, b) => b - a);
          allIndices.forEach(index => gameState.players[gameState.currentPlayer].hand.splice(index, 1));
          gameState.selectedCards = [];
          updateDisplay();
          return;
        }
        resultCells = existingTokensInSet;
        console.log(`Intersection: ได้พื้นที่ที่มีเบี้ยอยู่แล้ว ${resultCells.length} ช่อง: ${resultCells.join(', ')}`);
      }
      break;
      
    case 'difference':
      // ตรวจสอบการ์ดเซตว่าง (ไม่มี cells หรือ cells เป็น array ว่าง)
      if (!setCard.cells || setCard.cells.length === 0) {
        // 2.1.3 เซตใด ๆ ผลต่างกับเซตว่าง: ไม่เกิดผลใด ๆ กับสมาชิกที่อยู่บนกระดาน
        console.log('Difference with empty set: No effect on board');
        resultCells = [];
      } else {
        // Difference: ลบเบี้ยทั้งหมดในพื้นที่การ์ดเซตออกจากกระดาน (ไม่ว่าจะเป็นของใคร)
        // ไม่ได้พื้นที่เพิ่ม แค่ลบเบี้ยออก
        const tokensInSetArea = setCard.cells.filter(pos => 
          gameState.board[pos] // มีเบี้ยอยู่ในตำแหน่งนี้
        );
        
        if (tokensInSetArea.length === 0) {
          showToast('ไม่มีเบี้ยในพื้นที่เซตนี้ที่จะลบได้!', 'warning');
          
          // ลบการ์ดที่ใช้ทั้งสองใบแม้ไม่สำเร็จ
          const setIndex = gameState.selectedCards.find(i => gameState.players[gameState.currentPlayer].hand[i].type === 'set');
          const markerIndex = gameState.selectedCards.find(i => gameState.players[gameState.currentPlayer].hand[i].type === 'marker');
          const allIndices = [setIndex, markerIndex].sort((a, b) => b - a);
          allIndices.forEach(index => gameState.players[gameState.currentPlayer].hand.splice(index, 1));
          
          gameState.selectedCards = [];
          updateDisplay();
          return;
        }
        
        // ลบเบี้ยทั้งหมดในพื้นที่การ์ดเซต (ไม่ว่าจะเป็นของใคร)
        tokensInSetArea.forEach(pos => {
          delete gameState.board[pos];
          const cell = document.querySelector(`[data-position="${pos}"]`);
          if(cell) {
            cell.innerHTML = pos;
            cell.style.backgroundColor = 'white';
          }
        });
        
        // อัพเดทจำนวนเบี้ยหลังลบ
        updateTokenCounts();
        
        // ไม่ได้พื้นที่เพิ่ม - แค่ลบเบี้ยทั้งหมดในเซต
        resultCells = [];
        
        console.log(`Difference: ลบเบี้ยทั้งหมด ${tokensInSetArea.length} ช่อง: ${tokensInSetArea.join(', ')}`);
      }
      break;
      
    case 'complement':
      // ตรวจสอบการ์ดเซตว่าง (ไม่มี cells หรือ cells เป็น array ว่าง)
      if (!setCard.cells || setCard.cells.length === 0) {
        // 2.1.4 เซตว่างคอมพลีเมนต์: ได้สมาชิกทั้งหมดบนกระดาน (ทุกช่อง)
        console.log('🔥 DEBUG: Complement of empty set detected');
        const allCells = [];
        for (let row = 0; row < 8; row++) {
          for (let col = 0; col < 8; col++) {
            allCells.push(`${String.fromCharCode(65 + row)}${col + 1}`);
          }
        }
        resultCells = allCells;
        console.log(`🔥 DEBUG: Complement of empty set - got ${allCells.length} cells`);
      } else {
        // 3. เซตใด ๆ คอมพลีเมนต์: ยึดทุกช่องบนกระดาน ยกเว้นช่องบนการ์ดเซต
        console.log('🔥 DEBUG: Complement of normal set detected');
        console.log('🔥 DEBUG: Set cells:', setCard.cells);
        console.log('🔥 DEBUG: Set size:', setCard.cells.length);
        
        // หาทุกช่องบนกระดาน (ทั้งที่มีและไม่มีเบี้ย)
        const allCells = [];
        for (let row = 0; row < 8; row++) {
          for (let col = 0; col < 8; col++) {
            allCells.push(`${String.fromCharCode(65 + row)}${col + 1}`);
          }
        }
        
        // ยกเว้นพื้นที่ที่อยู่ในการ์ดเซต
        resultCells = allCells.filter(pos => !setCard.cells.includes(pos));
        
        console.log(`🔥 DEBUG: Total cells: ${allCells.length}, Set cells: ${setCard.cells.length}, Result: ${resultCells.length}`);
        console.log('🔥 DEBUG: Expected result:', allCells.length - setCard.cells.length);
        console.log('🔥 DEBUG: Result cells (first 10):', resultCells.slice(0, 10));
      }
      break;
  }
  
  // หากการดำเนินการไม่เกิดผลใดๆ ก็ปล่อยให้เกิดการดำเนินการได้ (ตามคำขอผู้ใช้)
  // เฉพาะ Difference ที่ไม่ได้พื้นที่เพิ่มเท่านั้นที่ต้องข้ามการตรวจสอบ
  console.log(`${markerCard.subtype} operation result:`, resultCells ? resultCells.length : 0, 'cells');
  
  // ตรวจสอบความถูกต้องของตำแหน่ง
  const validCells = resultCells.filter(pos => {
    const letter = pos.charAt(0);
    const number = parseInt(pos.charAt(1));
    return letter >= 'A' && letter <= 'H' && number >= 1 && number <= 8;
  });
  
  if(validCells.length !== resultCells.length) {
    alert('พบตำแหน่งที่ไม่ถูกต้องในการดำเนินการ!');
    return;
  }
  
  resultCells = validCells;
  
  // วางเบี้ยตามผลลัพธ์ (ยกเว้น Difference ที่ไม่ได้พื้นที่เพิ่ม)
  let capturedTokens = 0; // ประกาศตัวแปรให้อยู่ในขอบเขตที่ใช้ได้ทั่วทั้งฟังก์ชัน
  
  console.log('🔥 DEBUG: About to place tokens for', markerCard.subtype);
  console.log('🔥 DEBUG: ResultCells length:', resultCells ? resultCells.length : 0);
  
  if(markerCard.subtype !== 'difference') {
    // อนุญาตให้ทำงานแม้ไม่มี resultCells (กรณีการดำเนินการว่าง)
    if(resultCells && resultCells.length > 0) {
      const originalTokens = resultCells.filter(pos => gameState.board[pos] === gameState.currentPlayer).length;
      capturedTokens = resultCells.filter(pos => gameState.board[pos] && gameState.board[pos] !== gameState.currentPlayer).length;
      
      console.log(`🔥 DEBUG: Placing tokens on ${resultCells.length} cells`);
      console.log('🔥 DEBUG: First 10 cells:', resultCells.slice(0, 10));
      
      try {
        resultCells.forEach(pos => {
          gameState.board[pos] = gameState.currentPlayer;
          const cell = document.querySelector(`[data-position="${pos}"]`);
          if(cell) {
            const chip = document.createElement('div');
            chip.className = `chip ${gameState.currentPlayer}`;
            chip.textContent = gameState.currentPlayer === 'black' ? '⚫' : '⚪';
            cell.innerHTML = '';
            cell.appendChild(chip);
            
            // เพิ่มสีพื้นหลังแสดงการครอบครอง
            cell.style.backgroundColor = gameState.currentPlayer === 'black' ? '#f3f4f6' : '#fef3c7';
          } else {
            console.error(`Cannot find cell for position: ${pos}`);
          }
        });
        
        updateTokenCounts();
        console.log(`Successfully placed tokens. New board state:`, gameState.board);
      } catch (error) {
        console.error('Error placing tokens:', error);
        alert('เกิดข้อผิดพลาดในการวางเบี้ย: ' + error.message);
        return;
      }
    } else {
      console.log(`${markerCard.subtype} operation completed with no cells to place`);
    }
  }
  try {
    gameState.cardsPlacedThisTurn.set = true;
    gameState.cardsPlacedThisTurn.marker = true;
    
    // สำหรับ Difference จะมีการ log ข้อความแล้วในขั้นตอนการลบเบี้ย
    if(markerCard.subtype !== 'difference') {
      const playerName = gameState.currentPlayer === 'black' ? 'ผู้เล่นดำ' : 'ผู้เล่นขาว';
      const cellCount = resultCells ? resultCells.length : 0;
      let logMsg = `${playerName} ใช้ ${setCard.label} + ${markerCard.label}`;
      
      if (cellCount > 0) {
        logMsg += ` ได้ ${cellCount} ช่อง`;
        if (markerCard.subtype === 'union' && capturedTokens > 0) {
          logMsg += ` (รวมเบี้ยติดกัน ${capturedTokens} ช่อง)`;
        }
      } else {
        logMsg += ` (ไม่มีการเปลี่ยนแปลง)`;
      }
      
      logMessage(logMsg);
    }
    
    // ลบการ์ดที่ใช้ทั้งสองใบ
    const setIndex = gameState.selectedCards.find(i => gameState.players[gameState.currentPlayer].hand[i].type === 'set');
    const markerIndex = gameState.selectedCards.find(i => gameState.players[gameState.currentPlayer].hand[i].type === 'marker');
    
    if (setIndex === undefined || markerIndex === undefined) {
      console.error('Cannot find card indices:', { setIndex, markerIndex, selectedCards: gameState.selectedCards });
      throw new Error('ไม่พบการ์ดที่เลือก');
    }
    
    const allIndices = [setIndex, markerIndex].sort((a, b) => b - a);
    allIndices.forEach(index => {
      if (index >= 0 && index < gameState.players[gameState.currentPlayer].hand.length) {
        gameState.players[gameState.currentPlayer].hand.splice(index, 1);
      } else {
        console.error(`Invalid card index: ${index}`);
      }
    });
    
    gameState.selectedCards = [];
    updateDisplay();
    
    updateGameStatus('กดข้ามเทิร์นเพื่อจบเทิร์น');
    enableButtons(['skipTurnBtn']);
  } catch (error) {
    console.error('Error in applySetWithMarker cleanup:', error);
    alert('เกิดข้อผิดพลาดในการจัดการการ์ด: ' + error.message);
  }
};

// ทิ้งการ์ด
const discardCard = () => {
  if(gameState.turnPhase !== 'action') {
    alert('ต้องจั่วการ์ดก่อนทิ้งการ์ด!');
    return;
  }
  
  if(gameState.selectedCards.length !== 1) {
    alert('เลือกการ์ด 1 ใบที่ต้องการทิ้ง!');
    return;
  }
  
  const cardIndex = gameState.selectedCards[0];
  const card = gameState.players[gameState.currentPlayer].hand[cardIndex];
  
  gameState.players[gameState.currentPlayer].hand.splice(cardIndex, 1);
  gameState.selectedCards = [];
  
  const playerName = getPlayerName(gameState.currentPlayer);
  logMessage(`${playerName} ทิ้งการ์ด: ${card.label}`);
  
  updateDisplay();
  
  // จบเทิร์นทันทีหลังทิ้งการ์ด
  setTimeout(() => {
    skipTurn();
  }, 1000);
  
  updateGameStatus('ทิ้งการ์ดแล้ว - จะจบเทิร์นในอีก 1 วินาที...');
  enableButtons([]);
};

// ข้ามเทิร์น
const skipTurn = () => {
  if(gameState.phase === 'playing' && gameState.turnPhase === 'draw' && !gameState.drawnThisTurn) {
    alert('ต้องจั่วการ์ดก่อนข้ามเทิร์น!');
    return;
  }
  
  const playerName = gameState.currentPlayer === 'black' ? 'ผู้เล่นดำ' : 'ผู้เล่นขาว';
  
  if(gameState.phase === 'playing') {
    // ถ้าอยู่ในช่วง action ให้จบเทิร์นทันที
    if(gameState.turnPhase === 'action') {
      logMessage(`${playerName} ข้ามการใช้สิทธิ์`);
    } else {
      logMessage(`${playerName} จบเทิร์น`);
    }
    
    // เปลี่ยนผู้เล่น
    gameState.currentPlayer = gameState.currentPlayer === 'black' ? 'white' : 'black';
    if(gameState.currentPlayer === 'black') {
      gameState.turn++;
    }
    
    // ตรวจสอบจบเกม - เอาเงื่อนไขเทิร์นออก ให้ผู้เล่นเลือกจบเกมเอง
    // if(gameState.turn > 20) {
    //   endGame();
    //   return;
    // }
    
    // รีเซ็ตสถานะเทิร์น
    gameState.turnPhase = 'draw';
    gameState.drawnThisTurn = false;
    gameState.cardsPlacedThisTurn = { set: false, marker: false };
    gameState.selectedCards = [];
    
    // รีเซ็ตปุ่มทั้งหมดก่อน update
    enableButtons([]);
    
    updateDisplay();
    
    const nextPlayerName = getPlayerName(gameState.currentPlayer);
    
    updateGameStatus(`${nextPlayerName}: จั่วการ์ด 1 ใบก่อน`);
    enableButtons(['drawSetBtn', 'drawMarkerBtn']);
  }
};

// จบเกม
const endGame = () => {
  gameState.phase = 'finished';
  
  const blackScore = calculateScore('black');
  const whiteScore = calculateScore('white');
  
  const blackPlayerName = getPlayerName('black');
  const whitePlayerName = getPlayerName('white');
  
  let winner, message;
  if(blackScore > whiteScore) {
    winner = `${blackPlayerName}ชนะ!`;
    message = `🎉 ${blackPlayerName}ชนะ! (${blackScore} > ${whiteScore})`;
  } else if(whiteScore > blackScore) {
    winner = `${whitePlayerName}ชนะ!`;
    message = `🎉 ${whitePlayerName}ชนะ! (${whiteScore} > ${blackScore})`;
  } else {
    winner = 'เสมอกัน!';
    message = `🤝 เสมอกัน! (${blackScore} = ${whiteScore})`;
  }
  
  logMessage('🏁 จบเกม! ผลการแข่งขัน:');
  logMessage(`   ${blackPlayerName}: ${blackScore} คะแนน (เบี้ย ${gameState.players.black.tokens} - การ์ด ${gameState.players.black.hand.length})`);
  logMessage(`   ${whitePlayerName}: ${whiteScore} คะแนน (เบี้ย ${gameState.players.white.tokens} - การ์ด ${gameState.players.white.hand.length})`);
  logMessage(message);
  
  updateDisplay();
  updateGameStatus('เกมจบแล้ว! กดเริ่มเกมใหม่เพื่อเล่นอีกครั้ง');
  enableButtons([]);
};

// Loading state helpers
const setButtonLoading = (buttonId, loading = true, originalText = '') => {
  const button = document.getElementById(buttonId);
  if (!button) return;
  
  if (loading) {
    button.dataset.originalText = button.textContent;
    button.classList.add('loading');
    button.disabled = true;
  } else {
    button.classList.remove('loading');
    button.textContent = originalText || button.dataset.originalText;
    delete button.dataset.originalText;
  }
};

// Enhanced action functions with loading states
const drawSetCardWithLoading = async () => {
  setButtonLoading('drawSetBtn', true);
  try {
    await new Promise(resolve => setTimeout(resolve, 300)); // Simulate processing
    drawSetCard();
  } finally {
    setTimeout(() => setButtonLoading('drawSetBtn', false), 100);
  }
};

const drawMarkerCardWithLoading = async () => {
  setButtonLoading('drawMarkerBtn', true);
  try {
    await new Promise(resolve => setTimeout(resolve, 300));
    drawMarkerCard();
  } finally {
    setTimeout(() => setButtonLoading('drawMarkerBtn', false), 100);
  }
};

const placeCardsWithLoading = async () => {
  setButtonLoading('placeCardsBtn', true);
  try {
    await new Promise(resolve => setTimeout(resolve, 400)); // Longer for placement
    placeCards();
  } finally {
    setTimeout(() => setButtonLoading('placeCardsBtn', false), 100);
  }
};

const discardCardWithLoading = async () => {
  setButtonLoading('discardBtn', true);
  try {
    await new Promise(resolve => setTimeout(resolve, 200));
    discardCard();
  } finally {
    setTimeout(() => setButtonLoading('discardBtn', false), 100);
  }
};

const skipTurnWithLoading = async () => {
  setButtonLoading('skipTurnBtn', true);
  try {
    await new Promise(resolve => setTimeout(resolve, 250));
    skipTurn();
  } finally {
    setTimeout(() => setButtonLoading('skipTurnBtn', false), 100);
  }
};

// Event Listeners
document.getElementById('newGameBtn').onclick = startNewGame;
document.getElementById('drawSetBtn').onclick = drawSetCardWithLoading;
document.getElementById('drawMarkerBtn').onclick = drawMarkerCardWithLoading;
document.getElementById('placeCardsBtn').onclick = placeCardsWithLoading;
document.getElementById('discardBtn').onclick = discardCardWithLoading;
document.getElementById('skipTurnBtn').onclick = skipTurnWithLoading;

// ฟังก์ชันแสดง/ซ่อนข้อมูลการ์ด
const toggleCardInfo = () => {
  const content = document.getElementById('card-info-content');
  const icon = document.getElementById('toggle-icon');
  const text = document.getElementById('toggle-text');
  
  if (content.classList.contains('show')) {
    content.classList.remove('show');
    icon.textContent = '👁️';
    text.textContent = 'แสดงข้อมูลการ์ด';
  } else {
    content.classList.add('show');
    icon.textContent = '🙈';
    text.textContent = 'ซ่อนข้อมูลการ์ด';
  }
};

// ฟังก์ชันอัพเดทการนับการ์ดคงเหลือ
const updateCardCounts = () => {
  const setElement = document.getElementById('remaining-set-cards');
  const markerElement = document.getElementById('remaining-marker-cards');
  
  if (setElement && gameState && gameState.deckSet) {
    setElement.textContent = `เหลือในเด็ค: ${gameState.deckSet.length} ใบ`;
  }
  
  if (markerElement && gameState && gameState.deckMarker) {
    markerElement.textContent = `เหลือในเด็ค: ${gameState.deckMarker.length} ใบ`;
  }
};

// เริ่มต้น
createBoard();
updateDisplay();
enableButtons([]);
</script>
</body>
</html>
