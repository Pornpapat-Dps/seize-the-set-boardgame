<!DOCTYPE html>
<html lang="th">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
<title>Seize The Set Boardgame - ‡πÄ‡∏Å‡∏°‡∏¢‡∏∂‡∏î‡∏Ñ‡∏£‡∏≠‡∏á‡πÄ‡∏ã‡∏ï</title>
<style>
  :root {
    --primary: #ff4f9a;
    --secondary: #7c3aed;
    --dark: #1f2937;
    --light: #f8fafc;
    --success: #10b981;
    --warning: #f59e0b;
    --danger: #ef4444;
  }

  * {
    margin: 0;
    padding: 0;
    box-sizing: border-box;
  }

  body {
    font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
    background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
    min-height: 100vh;
    color: var(--dark);
  }

  .container {
    max-width: 1400px;
    margin: 0 auto;
    padding: 20px;
  }
  
  /* Responsive ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡∏´‡∏ô‡πâ‡∏≤‡∏à‡∏≠‡∏Ç‡∏ô‡∏≤‡∏î‡∏ï‡πà‡∏≤‡∏á‡πÜ */
  @media (max-width: 768px) {
    .container {
      padding: 10px;
    }
  }

  .header {
    text-align: center;
    background: white;
    border-radius: 15px;
    padding: 30px;
    margin-bottom: 30px;
    box-shadow: 0 10px 30px rgba(0,0,0,0.1);
  }

  .header h1 {
    font-size: 2.5rem;
    background: linear-gradient(45deg, var(--primary), var(--secondary));
    -webkit-background-clip: text;
    background-clip: text;
    -webkit-text-fill-color: transparent;
    margin-bottom: 10px;
  }
  
  /* Responsive Header */
  @media (max-width: 768px) {
    .header {
      padding: 20px;
      margin-bottom: 20px;
    }
    
    .header h1 {
      font-size: 1.8rem;
    }
  }
  
  @media (max-width: 480px) {
    .header h1 {
      font-size: 1.5rem;
    }
  }

  .game-area {
    display: grid;
    grid-template-columns: 1fr 400px;
    gap: 30px;
    margin-bottom: 30px;
  }
  
  /* Responsive Game Area */
  @media (max-width: 1024px) {
    .game-area {
      grid-template-columns: 1fr 350px;
      gap: 20px;
    }
  }
  
  @media (max-width: 768px) {
    .game-area {
      grid-template-columns: 1fr;
      gap: 20px;
      margin-bottom: 20px;
    }
  }

  .board-section {
    background: white;
    border-radius: 15px;
    padding: 25px;
    box-shadow: 0 10px 30px rgba(0,0,0,0.1);
  }

  .control-panel {
    background: white;
    border-radius: 15px;
    padding: 25px;
    box-shadow: 0 10px 30px rgba(0,0,0,0.1);
  }
  
  /* Responsive Panels */
  @media (max-width: 768px) {
    .board-section, .control-panel {
      padding: 15px;
    }
  }
  
  @media (max-width: 480px) {
    .board-section, .control-panel {
      padding: 12px;
    }
  }

  .card-info-panel {
    background: white;
    border-radius: 15px;
    padding: 25px;
    margin-bottom: 30px;
    box-shadow: 0 10px 30px rgba(0,0,0,0.1);
  }

  .toggle-card-info {
    background: var(--primary);
    color: white;
    border: none;
    border-radius: 10px;
    padding: 12px 20px;
    font-weight: bold;
    cursor: pointer;
    transition: all 0.3s ease;
    margin-bottom: 20px;
    display: flex;
    align-items: center;
    gap: 10px;
    width: 100%;
    justify-content: center;
  }

  .toggle-card-info:hover {
    background: var(--secondary);
    transform: translateY(-2px);
  }

  .card-info-content {
    display: none;
    animation: slideDown 0.3s ease;
  }

  .card-info-content.show {
    display: block;
  }

  @keyframes slideDown {
    from {
      opacity: 0;
      transform: translateY(-20px);
    }
    to {
      opacity: 1;
      transform: translateY(0);
    }
  }

  .card-info-grid {
    display: grid;
    grid-template-columns: 1fr 1fr;
    gap: 30px;
  }

  .card-category {
    background: linear-gradient(135deg, #f8fafc 0%, #e2e8f0 100%);
    border-radius: 10px;
    padding: 20px;
    border-left: 4px solid var(--primary);
  }

  .card-category h4 {
    color: var(--primary);
    margin-bottom: 15px;
    font-size: 1.2rem;
    display: flex;
    align-items: center;
    gap: 10px;
  }

  .card-list {
    display: grid;
    grid-template-columns: 1fr 1fr;
    gap: 10px;
  }

  .card-item {
    background: white;
    border-radius: 8px;
    padding: 12px;
    display: flex;
    justify-content: space-between;
    align-items: center;
    border: 1px solid #e2e8f0;
    transition: all 0.3s ease;
  }

  .card-item:hover {
    border-color: var(--primary);
    transform: translateY(-2px);
    box-shadow: 0 4px 12px rgba(0,0,0,0.1);
  }

  .card-name {
    font-weight: 600;
    color: var(--dark);
  }

  .card-count {
    background: var(--primary);
    color: white;
    border-radius: 20px;
    padding: 4px 12px;
    font-size: 0.9rem;
    font-weight: bold;
  }

  .total-cards {
    text-align: center;
    margin-top: 20px;
    padding: 15px;
    background: linear-gradient(45deg, var(--primary), var(--secondary));
    color: white;
    border-radius: 10px;
    font-weight: bold;
    font-size: 1.1rem;
  }

  .game-board {
    display: grid;
    grid-template-columns: 40px repeat(8, 60px);
    grid-template-rows: 40px repeat(8, 60px);
    gap: 3px;
    margin: 20px auto;
    background: var(--dark);
    padding: 10px;
    border-radius: 10px;
    max-width: 100%;
    overflow-x: auto;
    box-shadow: 0 8px 25px rgba(0,0,0,0.15);
    transition: box-shadow 0.3s ease;
  }

  .game-board:hover {
    box-shadow: 0 12px 35px rgba(0,0,0,0.2);
  }
  
  /* Responsive Game Board */
  @media (max-width: 768px) {
    .game-board {
      grid-template-columns: 30px repeat(8, 45px);
      grid-template-rows: 30px repeat(8, 45px);
      gap: 2px;
      padding: 8px;
    }
  }
  
  @media (max-width: 480px) {
    .game-board {
      grid-template-columns: 25px repeat(8, 35px);
      grid-template-rows: 25px repeat(8, 35px);
      gap: 1px;
      padding: 6px;
    }
  }

  .cell {
    display: flex;
    align-items: center;
    justify-content: center;
    background: white;
    border-radius: 5px;
    font-weight: bold;
    font-size: 0.9rem;
    position: relative;
    cursor: pointer;
    transition: all 0.3s ease;
  }

  .cell.header {
    background: var(--dark);
    color: white;
    font-size: 0.8rem;
  }
  
  /* Responsive Cell */
  @media (max-width: 768px) {
    .cell {
      font-size: 0.7rem;
    }
    
    .cell.header {
      font-size: 0.6rem;
    }
  }
  
  @media (max-width: 480px) {
    .cell {
      font-size: 0.6rem;
    }
    
    .cell.header {
      font-size: 0.5rem;
    }
  }

  .cell.game-cell {
    min-height: 60px;
    border: 2px solid transparent;
  }

  .cell.game-cell:hover {
    border-color: var(--warning);
    transform: scale(1.05);
  }

  .chip {
    width: 40px;
    height: 40px;
    border-radius: 50%;
    display: flex;
    align-items: center;
    justify-content: center;
    font-weight: bold;
    color: white;
    text-shadow: 1px 1px 2px rgba(0,0,0,0.5);
    animation: chipPlace 0.5s ease-out;
  }

  @keyframes chipPlace {
    0% {
      transform: scale(0) rotate(180deg);
      opacity: 0;
    }
    50% {
      transform: scale(1.2) rotate(90deg);
      opacity: 0.8;
    }
    100% {
      transform: scale(1) rotate(0deg);
      opacity: 1;
    }
  }

  .chip.black {
    background: linear-gradient(145deg, #374151, #111827);
    box-shadow: inset 2px 2px 5px rgba(255,255,255,0.2), inset -2px -2px 5px rgba(0,0,0,0.5);
  }

  .chip.white {
    background: linear-gradient(145deg, #f9fafb, #e5e7eb);
    color: var(--dark);
    box-shadow: inset 2px 2px 5px rgba(255,255,255,0.8), inset -2px -2px 5px rgba(0,0,0,0.1);
  }
  
  /* Responsive Chip */
  @media (max-width: 768px) {
    .chip {
      width: 30px;
      height: 30px;
      font-size: 0.8rem;
    }
    
    .cell.game-cell {
      min-height: 45px;
    }
  }
  
  @media (max-width: 480px) {
    .chip {
      width: 25px;
      height: 25px;
      font-size: 0.7rem;
    }
    
    .cell.game-cell {
      min-height: 35px;
    }
  }

  .score-display {
    display: flex;
    justify-content: space-between;
    align-items: center;
    background: linear-gradient(135deg, #f0f4f8, #e2e8f0);
    padding: 20px;
    border-radius: 10px;
    margin-bottom: 20px;
  }

  .player-score {
    display: flex;
    align-items: center;
    gap: 10px;
  }

  .player-score .chip {
    width: 30px;
    height: 30px;
    font-size: 0.8rem;
  }

  .turn-info {
    background: var(--primary);
    color: white;
    padding: 15px;
    border-radius: 10px;
    text-align: center;
    margin-bottom: 20px;
    font-weight: bold;
    font-size: 1.1rem;
    transition: all 0.3s ease;
    box-shadow: 0 4px 15px rgba(0,0,0,0.1);
  }

  .turn-info.active {
    animation: subtlePulse 2s infinite;
  }

  @keyframes subtlePulse {
    0%, 100% {
      box-shadow: 0 4px 15px rgba(0,0,0,0.1);
    }
    50% {
      box-shadow: 0 8px 25px rgba(0,0,0,0.2);
    }
  }

  .turn-info.black-turn {
    background: linear-gradient(135deg, #374151, #111827);
  }

  .turn-info.white-turn {
    background: linear-gradient(135deg, #f9fafb, #e5e7eb);
    color: var(--dark);
  }

  .current-player-indicator {
    display: inline-flex;
    align-items: center;
    gap: 8px;
    font-size: 1.2rem;
  }

  .actions {
    display: grid;
    grid-template-columns: 1fr 1fr;
    gap: 10px;
    margin-bottom: 20px;
  }

  .btn {
    padding: 12px 20px;
    border: none;
    border-radius: 8px;
    font-weight: bold;
    cursor: pointer;
    transition: all 0.3s ease;
    font-size: 0.9rem;
    outline: none;
    position: relative;
  }

  .btn:focus-visible {
    outline: 2px solid var(--primary);
    outline-offset: 2px;
    box-shadow: 0 0 0 4px rgba(255, 79, 154, 0.2);
  }
  
  /* Responsive Buttons */
  @media (max-width: 768px) {
    .actions {
      grid-template-columns: 1fr;
      gap: 8px;
    }
    
    .btn {
      padding: 10px 16px;
      font-size: 0.8rem;
    }
  }
  
  @media (max-width: 480px) {
    .btn {
      padding: 8px 12px;
      font-size: 0.75rem;
    }
  }

  .btn:hover {
    transform: translateY(-2px);
    box-shadow: 0 5px 15px rgba(0,0,0,0.2);
  }

  .btn.primary {
    background: var(--primary);
    color: white;
  }

  .btn.secondary {
    background: var(--secondary);
    color: white;
  }

  .btn.success {
    background: var(--success);
    color: white;
  }

  .btn.warning {
    background: var(--warning);
    color: white;
  }

  .btn.danger {
    background: var(--danger);
    color: white;
  }

  .btn:disabled {
    opacity: 0.5;
    cursor: not-allowed;
    transform: none;
  }

  .btn.loading {
    position: relative;
    color: transparent;
  }

  .btn.loading::after {
    content: '';
    position: absolute;
    top: 50%;
    left: 50%;
    width: 20px;
    height: 20px;
    border: 2px solid rgba(255, 255, 255, 0.3);
    border-top: 2px solid white;
    border-radius: 50%;
    animation: spin 1s linear infinite;
    transform: translate(-50%, -50%);
  }

  @keyframes spin {
    0% { transform: translate(-50%, -50%) rotate(0deg); }
    100% { transform: translate(-50%, -50%) rotate(360deg); }
  }

  /* Toast Notification System */
  .toast-container {
    position: fixed;
    top: 20px;
    right: 20px;
    z-index: 1000;
    display: flex;
    flex-direction: column;
    gap: 10px;
  }

  .toast {
    background: white;
    border-radius: 10px;
    padding: 15px 20px;
    box-shadow: 0 5px 20px rgba(0,0,0,0.2);
    border-left: 4px solid;
    min-width: 300px;
    max-width: 400px;
    animation: slideInRight 0.3s ease, fadeOut 0.3s ease 4.7s forwards;
    display: flex;
    align-items: center;
    gap: 10px;
  }

  .toast.success {
    border-left-color: var(--success);
  }

  .toast.warning {
    border-left-color: var(--warning);
  }

  .toast.error {
    border-left-color: var(--danger);
  }

  .toast.info {
    border-left-color: var(--primary);
  }

  .toast-icon {
    font-size: 1.2rem;
  }

  .toast-message {
    flex: 1;
    font-weight: 500;
  }

  .toast-close {
    background: none;
    border: none;
    font-size: 1.2rem;
    cursor: pointer;
    opacity: 0.6;
    transition: opacity 0.2s;
  }

  .toast-close:hover {
    opacity: 1;
  }

  @keyframes slideInRight {
    from {
      transform: translateX(100%);
      opacity: 0;
    }
    to {
      transform: translateX(0);
      opacity: 1;
    }
  }

  @keyframes fadeOut {
    to {
      opacity: 0;
      transform: translateX(100%);
    }
  }

  /* Responsive Toast */
  @media (max-width: 768px) {
    .toast-container {
      top: 10px;
      right: 10px;
      left: 10px;
    }
    
    .toast {
      min-width: auto;
      max-width: none;
    }
  }

  .hand {
    background: #f8fafc;
    border-radius: 10px;
    padding: 15px;
    margin-bottom: 20px;
  }

  .hand h4 {
    margin-bottom: 10px;
    color: var(--dark);
  }

  .cards {
    display: flex;
    flex-wrap: wrap;
    gap: 8px;
  }

  .card {
    background: white;
    border: 2px solid var(--dark);
    border-radius: 8px;
    padding: 8px 12px;
    font-size: 0.8rem;
    cursor: pointer;
    transition: all 0.3s ease;
    position: relative;
    outline: none;
    box-shadow: 0 2px 8px rgba(0,0,0,0.1);
  }

  .card .card-details {
    font-size: 0.7rem;
    color: #666;
    margin-top: 4px;
    line-height: 1.2;
    transition: color 0.3s ease;
  }

  .card:hover {
    background: var(--primary);
    color: white;
    transform: scale(1.05) translateY(-2px);
    box-shadow: 0 8px 25px rgba(0,0,0,0.15);
  }

  .card:hover .card-details {
    color: rgba(255,255,255,0.8);
  }

  .card:focus-visible {
    outline: 2px solid var(--primary);
    outline-offset: 2px;
  }

  .card:active {
    transform: scale(0.98);
  }
  
  /* Responsive Cards */
  @media (max-width: 768px) {
    .hand {
      padding: 12px;
    }
    
    .cards {
      gap: 6px;
    }
    
    .card {
      padding: 6px 10px;
      font-size: 0.7rem;
    }
    
    .card .card-details {
      font-size: 0.6rem;
    }
  }
  
  @media (max-width: 480px) {
    .hand {
      padding: 10px;
    }
    
    .card {
      padding: 4px 8px;
      font-size: 0.65rem;
    }
    
    .card .card-details {
      font-size: 0.55rem;
    }
  }

  .card.set {
    border-color: var(--success);
  }

  .card.marker {
    border-color: var(--secondary);
  }

  .card.selected {
    background: var(--warning);
    color: white;
    transform: scale(1.02) translateY(-4px);
    box-shadow: 0 8px 25px rgba(255,193,7,0.4);
    border-color: var(--warning);
  }

  .card.selected .card-details {
    color: rgba(255,255,255,0.9);
  }

  .game-log {
    background: #f8fafc;
    border-radius: 10px;
    padding: 15px;
    height: 200px;
    overflow-y: auto;
  }

  .log-entry {
    padding: 8px 0;
    border-bottom: 1px solid #e2e8f0;
    font-size: 0.9rem;
    animation: fadeInSlide 0.3s ease-out;
    transition: background-color 0.2s ease;
  }

  .log-entry:hover {
    background-color: rgba(59, 130, 246, 0.05);
  }

  @keyframes fadeInSlide {
    0% {
      opacity: 0;
      transform: translateX(-10px);
    }
    100% {
      opacity: 1;
      transform: translateX(0);
    }
  }

  .status-bar {
    background: linear-gradient(135deg, #e2e8f0, #cbd5e1);
    padding: 10px 15px;
    border-radius: 8px;
    margin-bottom: 15px;
    font-size: 0.9rem;
  }

  @media (max-width: 1200px) {
    .game-area {
      grid-template-columns: 1fr;
    }
    
    .game-board {
      grid-template-columns: 30px repeat(8, 45px);
      grid-template-rows: 30px repeat(8, 45px);
    }
    
    .cell.game-cell {
      min-height: 45px;
    }
    
    .chip {
      width: 30px;
      height: 30px;
    }
  }
</style>
</head>
<body>
  <div class="container">
    <div class="header">
      <h1>üéØ Seize The Set Boardgame</h1>
      <p>‡πÄ‡∏Å‡∏°‡∏¢‡∏∂‡∏î‡∏Ñ‡∏£‡∏≠‡∏á‡∏û‡∏∑‡πâ‡∏ô‡∏ó‡∏µ‡πà‡πÄ‡∏ã‡∏ï - ‡∏ú‡∏•‡∏±‡∏î‡∏Å‡∏±‡∏ô‡πÄ‡∏•‡πà‡∏ô 20 ‡πÄ‡∏ó‡∏¥‡∏£‡πå‡∏ô</p>
    </div>

    <div class="card-info-panel">
      <button class="toggle-card-info" onclick="toggleCardInfo()">
        <span id="toggle-icon">üëÅÔ∏è</span>
        <span id="toggle-text">‡πÅ‡∏™‡∏î‡∏á‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏Å‡∏≤‡∏£‡πå‡∏î</span>
      </button>
      
      <div class="card-info-content" id="card-info-content">
        <h3 style="text-align: center; margin-bottom: 25px; color: var(--primary);">üìö ‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏Å‡∏≤‡∏£‡πå‡∏î‡πÉ‡∏ô‡πÄ‡∏Å‡∏°</h3>
        <div class="card-info-grid">
        <div class="card-category">
          <h4>üé¥ ‡∏Å‡∏≤‡∏£‡πå‡∏î‡πÄ‡∏ã‡∏ï (Set Cards)</h4>
          <div class="card-list">
            <div class="card-item" title="‡∏Å‡∏≤‡∏£‡πå‡∏î‡∏Ç‡∏ô‡∏≤‡∏î 2√ó2 ‡∏ä‡πà‡∏≠‡∏á - ‡∏û‡∏∑‡πâ‡∏ô‡∏ê‡∏≤‡∏ô‡∏Ç‡∏≠‡∏á‡πÄ‡∏Å‡∏°">
              <span class="card-name">‡πÄ‡∏ã‡∏ï 2√ó2</span>
              <span class="card-count">49 ‡πÉ‡∏ö</span>
            </div>
            <div class="card-item" title="‡∏Å‡∏≤‡∏£‡πå‡∏î‡∏Ç‡∏ô‡∏≤‡∏î 4√ó4 ‡∏ä‡πà‡∏≠‡∏á - ‡∏ó‡∏£‡∏á‡∏û‡∏•‡∏±‡∏á‡πÅ‡∏ï‡πà‡∏´‡∏≤‡∏¢‡∏≤‡∏Å">
              <span class="card-name">‡πÄ‡∏ã‡∏ï 4√ó4</span>
              <span class="card-count">4 ‡πÉ‡∏ö</span>
            </div>
            <div class="card-item" title="‡πÄ‡∏õ‡πâ‡∏≤‡∏´‡∏°‡∏≤‡∏¢: ‡∏û‡∏∑‡πâ‡∏ô‡∏ó‡∏µ‡πà‡πÄ‡∏ä‡∏∑‡πà‡∏≠‡∏°‡∏ï‡πà‡∏≠‡∏ó‡∏µ‡πà‡πÄ‡∏•‡πá‡∏Å‡∏ó‡∏µ‡πà‡∏™‡∏∏‡∏î‡∏Ç‡∏≠‡∏á‡∏ù‡∏±‡πà‡∏á‡∏ï‡∏£‡∏á‡∏Ç‡πâ‡∏≤‡∏°">
              <span class="card-name">Empty Set ‚àÖ</span>
              <span class="card-count">10 ‡πÉ‡∏ö</span>
            </div>
          </div>
          <div class="total-cards">
            ‡∏£‡∏ß‡∏°‡∏Å‡∏≤‡∏£‡πå‡∏î‡πÄ‡∏ã‡∏ï: 63 ‡πÉ‡∏ö | 
            <span id="remaining-set-cards">‡πÄ‡∏´‡∏•‡∏∑‡∏≠‡πÉ‡∏ô‡πÄ‡∏î‡πá‡∏Ñ: ?</span>
          </div>
        </div>

        <div class="card-category">
          <h4>‚ö° ‡∏Å‡∏≤‡∏£‡πå‡∏î‡πÄ‡∏Ñ‡∏£‡∏∑‡πà‡∏≠‡∏á‡∏´‡∏°‡∏≤‡∏¢ (Marker Cards)</h4>
          <div class="card-list">
            <div class="card-item" title="‡∏£‡∏ß‡∏°‡∏û‡∏∑‡πâ‡∏ô‡∏ó‡∏µ‡πà + ‡∏¢‡∏∂‡∏î‡∏Ñ‡∏£‡∏≠‡∏á‡πÄ‡∏ö‡∏µ‡πâ‡∏¢‡∏ï‡∏¥‡∏î‡∏Å‡∏±‡∏ô (‡πÄ‡∏ó‡∏¥‡∏£‡πå‡∏ô 16+ ‡∏´‡πâ‡∏≤‡∏°‡πÉ‡∏ä‡πâ)">
              <span class="card-name">Union ‚à™</span>
              <span class="card-count">4 ‡πÉ‡∏ö</span>
            </div>
            <div class="card-item" title="‡πÑ‡∏î‡πâ‡πÄ‡∏â‡∏û‡∏≤‡∏∞‡∏û‡∏∑‡πâ‡∏ô‡∏ó‡∏µ‡πà‡∏ó‡∏µ‡πà‡∏°‡∏µ‡πÄ‡∏ö‡∏µ‡πâ‡∏¢‡∏≠‡∏¢‡∏π‡πà‡πÅ‡∏•‡πâ‡∏ß‡πÉ‡∏ô‡πÄ‡∏ã‡∏ï (‡πÑ‡∏°‡πà‡πÑ‡∏î‡πâ‡∏û‡∏∑‡πâ‡∏ô‡∏ó‡∏µ‡πà‡∏ß‡πà‡∏≤‡∏á)">
              <span class="card-name">Intersection ‚à©</span>
              <span class="card-count">12 ‡πÉ‡∏ö</span>
            </div>
            <div class="card-item" title="‡∏•‡∏ö‡πÄ‡∏ö‡∏µ‡πâ‡∏¢‡∏ó‡∏±‡πâ‡∏á‡∏´‡∏°‡∏î‡πÉ‡∏ô‡∏û‡∏∑‡πâ‡∏ô‡∏ó‡∏µ‡πà‡πÄ‡∏ã‡∏ï (‡πÑ‡∏°‡πà‡πÑ‡∏î‡πâ‡∏û‡∏∑‡πâ‡∏ô‡∏ó‡∏µ‡πà‡πÄ‡∏û‡∏¥‡πà‡∏°, ‡πÉ‡∏ä‡πâ‡∏Å‡∏±‡∏ö‡πÄ‡∏ã‡∏ï 1 ‡πÉ‡∏ö‡πÄ‡∏ó‡πà‡∏≤‡∏ô‡∏±‡πâ‡∏ô)">
              <span class="card-name">Difference \</span>
              <span class="card-count">12 ‡πÉ‡∏ö</span>
            </div>
            <div class="card-item" title="‡∏ó‡∏∏‡∏Å‡∏û‡∏∑‡πâ‡∏ô‡∏ó‡∏µ‡πà‡∏¢‡∏Å‡πÄ‡∏ß‡πâ‡∏ô‡∏Å‡∏≤‡∏£‡πå‡∏î‡πÄ‡∏ã‡∏ï (‡πÄ‡∏ó‡∏¥‡∏£‡πå‡∏ô 10+)">
              <span class="card-name">Complement ·∂ú</span>
              <span class="card-count">4 ‡πÉ‡∏ö</span>
            </div>
          </div>
          <div class="total-cards">
            ‡∏£‡∏ß‡∏°‡∏Å‡∏≤‡∏£‡πå‡∏î‡πÄ‡∏Ñ‡∏£‡∏∑‡πà‡∏≠‡∏á‡∏´‡∏°‡∏≤‡∏¢: 32 ‡πÉ‡∏ö | 
            <span id="remaining-marker-cards">‡πÄ‡∏´‡∏•‡∏∑‡∏≠‡πÉ‡∏ô‡πÄ‡∏î‡πá‡∏Ñ: ?</span>
          </div>
        </div>
        
        <div style="margin-top: 25px; padding: 20px; background: linear-gradient(135deg, #fff7ed 0%, #fed7aa 100%); border-radius: 10px; border-left: 4px solid var(--warning);">
          <!-- ‡∏Å‡∏é‡∏û‡∏¥‡πÄ‡∏®‡∏©‡∏ñ‡∏π‡∏Å‡∏•‡∏ö‡∏≠‡∏≠‡∏Å ‡πÑ‡∏°‡πà‡∏°‡∏µ‡∏Ç‡πâ‡∏≠‡∏à‡∏≥‡∏Å‡∏±‡∏î‡∏Å‡∏≤‡∏£‡πÉ‡∏ä‡πâ Union/Complement ‡∏ï‡∏≤‡∏°‡πÄ‡∏ó‡∏¥‡∏£‡πå‡∏ô -->
        </div>
      </div>
    </div>

    <div class="game-area">
      <div class="board-section">
        <h3>üé≤ ‡∏Å‡∏£‡∏∞‡∏î‡∏≤‡∏ô‡πÄ‡∏Å‡∏° 8x8</h3>
        <div id="gameBoard" class="game-board"></div>
      </div>

      <div class="control-panel" role="complementary" aria-label="Game controls and information">
        <div class="score-display" role="status" aria-live="polite">
          <div class="player-score">
            <div class="chip black" aria-hidden="true">‚ö´</div>
            <div>
              <div>‡∏ú‡∏π‡πâ‡πÄ‡∏•‡πà‡∏ô‡∏î‡∏≥</div>
              <div id="blackScore" aria-label="Black player score">0 ‡∏Ñ‡∏∞‡πÅ‡∏ô‡∏ô</div>
            </div>
          </div>
          <div class="player-score">
            <div class="chip white" aria-hidden="true">‚ö™</div>
            <div>
              <div>‡∏ú‡∏π‡πâ‡πÄ‡∏•‡πà‡∏ô‡∏Ç‡∏≤‡∏ß</div>
              <div id="whiteScore" aria-label="White player score">0 ‡∏Ñ‡∏∞‡πÅ‡∏ô‡∏ô</div>
            </div>
          </div>
        </div>

        <div id="turnInfo" class="turn-info" role="status" aria-live="polite">
          ‡πÄ‡∏Å‡∏°‡∏¢‡∏±‡∏á‡πÑ‡∏°‡πà‡πÄ‡∏£‡∏¥‡πà‡∏°
        </div>

        <div class="status-bar">
          <div id="gameStatus" role="status" aria-live="polite">‡∏Å‡∏î‡πÄ‡∏£‡∏¥‡πà‡∏°‡πÄ‡∏Å‡∏°‡πÉ‡∏´‡∏°‡πà‡πÄ‡∏û‡∏∑‡πà‡∏≠‡πÄ‡∏•‡πà‡∏ô</div>
        </div>

        <div class="actions" role="toolbar" aria-label="Game actions">
          <button id="drawSetBtn" class="btn success" disabled aria-describedby="turnInfo">‡∏à‡∏±‡πà‡∏ß‡∏Å‡∏≤‡∏£‡πå‡∏î‡πÄ‡∏ã‡∏ï</button>
          <button id="drawMarkerBtn" class="btn secondary" disabled aria-describedby="turnInfo">‡∏à‡∏±‡πà‡∏ß‡∏Å‡∏≤‡∏£‡πå‡∏î‡πÄ‡∏Ñ‡∏£‡∏∑‡πà‡∏≠‡∏á‡∏´‡∏°‡∏≤‡∏¢</button>
          <button id="placeCardsBtn" class="btn primary" disabled aria-describedby="turnInfo">‡∏•‡∏á‡∏Å‡∏≤‡∏£‡πå‡∏î</button>
          <button id="discardBtn" class="btn warning" disabled aria-describedby="turnInfo">‡∏ó‡∏¥‡πâ‡∏á‡∏Å‡∏≤‡∏£‡πå‡∏î</button>
          <button id="skipTurnBtn" class="btn danger" disabled aria-describedby="turnInfo">‡∏Ç‡πâ‡∏≤‡∏°/‡∏à‡∏ö‡πÄ‡∏ó‡∏¥‡∏£‡πå‡∏ô</button>
          <button id="newGameBtn" class="btn primary" aria-label="Start new game">‡πÄ‡∏£‡∏¥‡πà‡∏°‡πÄ‡∏Å‡∏°‡πÉ‡∏´‡∏°‡πà</button>
        </div>

        <div class="hand">
          <h4>üÉè ‡∏Å‡∏≤‡∏£‡πå‡∏î‡πÉ‡∏ô‡∏°‡∏∑‡∏≠</h4>
          <p style="font-size: 0.8rem; color: #666; margin-bottom: 10px;">
            üí° <strong>‡∏ß‡∏¥‡∏ò‡∏µ‡πÄ‡∏•‡πà‡∏ô:</strong> 1Ô∏è‚É£ ‡∏à‡∏±‡πà‡∏ß‡∏Å‡∏≤‡∏£‡πå‡∏î ‚Üí 2Ô∏è‚É£ ‡πÄ‡∏•‡∏∑‡∏≠‡∏Å‡πÉ‡∏ä‡πâ‡∏™‡∏¥‡∏ó‡∏ò‡∏¥‡πå (‡∏•‡∏á/‡∏ó‡∏¥‡πâ‡∏á/‡∏Ç‡πâ‡∏≤‡∏°) ‚Üí ‡∏à‡∏ö‡πÄ‡∏ó‡∏¥‡∏£‡πå‡∏ô‡∏ó‡∏±‡∏ô‡∏ó‡∏µ<br>
            üéØ <strong>‡πÄ‡∏Ñ‡∏£‡∏∑‡πà‡∏≠‡∏á‡∏´‡∏°‡∏≤‡∏¢:</strong> Union=‡∏£‡∏ß‡∏°+‡∏ï‡∏¥‡∏î‡∏Å‡∏±‡∏ô, Intersection=‡πÑ‡∏î‡πâ‡πÄ‡∏â‡∏û‡∏≤‡∏∞‡∏û‡∏∑‡πâ‡∏ô‡∏ó‡∏µ‡πà‡∏ó‡∏µ‡πà‡∏°‡∏µ‡πÄ‡∏ö‡∏µ‡πâ‡∏¢, Difference=‡∏•‡∏ö‡πÄ‡∏ö‡∏µ‡πâ‡∏¢‡∏ó‡∏±‡πâ‡∏á‡∏´‡∏°‡∏î‡πÉ‡∏ô‡πÄ‡∏ã‡∏ï(‡πÑ‡∏°‡πà‡πÑ‡∏î‡πâ‡∏û‡∏∑‡πâ‡∏ô‡∏ó‡∏µ‡πà), Complement=‡πÑ‡∏î‡πâ‡πÄ‡∏ö‡∏µ‡πâ‡∏¢‡∏ó‡∏±‡πâ‡∏á‡∏´‡∏°‡∏î‡∏¢‡∏Å‡πÄ‡∏ß‡πâ‡∏ô‡πÉ‡∏ô‡πÄ‡∏ã‡∏ï!<br>
            üåü <strong>‡πÄ‡∏ã‡∏ï‡∏ß‡πà‡∏≤‡∏á:</strong> Union=‡πÑ‡∏°‡πà‡∏°‡∏µ‡∏ú‡∏•, Intersection=‡∏•‡∏ö‡πÄ‡∏ö‡∏µ‡πâ‡∏¢‡∏ó‡∏±‡πâ‡∏á‡∏™‡∏≠‡∏á‡∏ù‡πà‡∏≤‡∏¢‡∏ó‡∏±‡πâ‡∏á‡∏´‡∏°‡∏î, Difference=‡πÑ‡∏°‡πà‡∏°‡∏µ‡∏ú‡∏•, Complement=‡πÑ‡∏î‡πâ‡πÄ‡∏ö‡∏µ‡πâ‡∏¢‡∏ó‡∏±‡πâ‡∏á‡∏´‡∏°‡∏î‡∏ó‡∏µ‡πà‡∏°‡∏µ‡∏≠‡∏¢‡∏π‡πà!
          </p>
          <div id="playerHand" class="cards"></div>
        </div>

        <div class="game-log">
          <h4>üìã ‡∏ö‡∏±‡∏ô‡∏ó‡∏∂‡∏Å‡∏Å‡∏≤‡∏£‡πÄ‡∏•‡πà‡∏ô</h4>
          <div id="gameLog"></div>
        </div>
      </div>
    </div>
  </div>

<script>
// ‡∏ï‡∏±‡∏ß‡πÅ‡∏õ‡∏£‡πÄ‡∏Å‡∏°
let gameState = {
  phase: 'waiting', // waiting, pregame, playing, finished
  turnPhase: 'draw', // draw, action
  turn: 0,
  currentPlayer: 'black', // black, white
  players: {
    black: { hand: [], score: 0, tokens: 0 },
    white: { hand: [], score: 0, tokens: 0 }
  },
  board: {},
  deckSet: [],
  deckMarker: [],
  drawnThisTurn: false,
  cardsPlacedThisTurn: { set: false, marker: false },
  selectedCards: []
};

// ‡∏Å‡∏≤‡∏£‡πå‡∏î‡πÄ‡∏ã‡∏ï 2x2 (49 ‡πÉ‡∏ö)
const generate2x2Cards = () => {
  const cards = [];
  const letters = ['A','B','C','D','E','F','G','H'];
  
  for(let r = 0; r < 7; r++) {
    for(let c = 0; c < 7; c++) {
      const cells = [
        `${letters[r]}${c+1}`, `${letters[r]}${c+2}`,
        `${letters[r+1]}${c+1}`, `${letters[r+1]}${c+2}`
      ];
      cards.push({
        type: 'set',
        subtype: '2x2',
        id: `2x2_${r}_${c}`,
        label: `2√ó2 ${letters[r]}${c+1}`,
        cells: cells
      });
    }
  }
  return cards;
};

// ‡∏Å‡∏≤‡∏£‡πå‡∏î‡πÄ‡∏ã‡∏ï 4x4 (4 ‡πÉ‡∏ö)
const generate4x4Cards = () => {
  const cards = [];
  const letters = ['A','B','C','D','E','F','G','H'];
  const quarters = [
    {r: 0, c: 0, name: 'Q1'}, {r: 0, c: 4, name: 'Q2'},
    {r: 4, c: 0, name: 'Q3'}, {r: 4, c: 4, name: 'Q4'}
  ];
  
  quarters.forEach(q => {
    const cells = [];
    for(let r = q.r; r < q.r + 4; r++) {
      for(let c = q.c; c < q.c + 4; c++) {
        cells.push(`${letters[r]}${c+1}`);
      }
    }
    cards.push({
      type: 'set',
      subtype: '4x4',
      id: `4x4_${q.name}`,
      label: `4√ó4 ${q.name}`,
      cells: cells
    });
  });
  
  return cards;
};

// ‡∏Å‡∏≤‡∏£‡πå‡∏î‡πÄ‡∏Ñ‡∏£‡∏∑‡πà‡∏≠‡∏á‡∏´‡∏°‡∏≤‡∏¢
const generateMarkerCards = () => {
  const cards = [];
  
  // Union (4 ‡πÉ‡∏ö)
  for(let i = 0; i < 4; i++) {
    cards.push({
      type: 'marker',
      subtype: 'union',
      id: `union_${i}`,
      label: 'Union (‚à™)'
    });
  }
  
  // Intersection (12 ‡πÉ‡∏ö)
  for(let i = 0; i < 12; i++) {
    cards.push({
      type: 'marker',
      subtype: 'intersection',
      id: `intersection_${i}`,
      label: 'Intersection (‚à©)'
    });
  }
  
  // Difference (12 ‡πÉ‡∏ö)
  for(let i = 0; i < 12; i++) {
    cards.push({
      type: 'marker',
      subtype: 'difference',
      id: `difference_${i}`,
      label: 'Difference (‚àí)'
    });
  }
  
  // Complement (4 ‡πÉ‡∏ö)
  for(let i = 0; i < 4; i++) {
    cards.push({
      type: 'marker',
      subtype: 'complement',
      id: `complement_${i}`,
      label: 'Complement (·∂ú)'
    });
  }
  
  return cards;
};

// ‡∏™‡∏£‡πâ‡∏≤‡∏á‡∏Å‡∏≤‡∏£‡πå‡∏î‡πÄ‡∏ã‡∏ï‡∏ß‡πà‡∏≤‡∏á (Empty Set)
const generateEmptySetCards = () => {
  const cards = [];
  for(let i = 0; i < 10; i++) {
    cards.push({
      type: 'set',
      subtype: 'empty',
      id: `empty_${i}`,
      label: 'Empty Set ‚àÖ',
      cells: [] // ‡πÑ‡∏°‡πà‡∏°‡∏µ‡∏û‡∏∑‡πâ‡∏ô‡∏ó‡∏µ‡πà
    });
  }
  return cards;
};

// ‡∏´‡∏≤‡∏û‡∏∑‡πâ‡∏ô‡∏ó‡∏µ‡πà‡∏ó‡∏µ‡πà‡πÄ‡∏ä‡∏∑‡πà‡∏≠‡∏°‡∏ï‡πà‡∏≠‡∏Å‡∏±‡∏ô‡∏ó‡∏±‡πâ‡∏á‡∏´‡∏°‡∏î
const getAllConnectedAreas = () => {
  const visited = new Set();
  const areas = [];
  
  for (let row = 0; row < 8; row++) {
    for (let col = 0; col < 8; col++) {
      const pos = `${String.fromCharCode(65 + row)}${col + 1}`;
      if (gameState.board[pos] && !visited.has(pos)) {
        const area = [];
        const playerColor = gameState.board[pos];
        
        const explore = (position) => {
          if (visited.has(position) || !gameState.board[position] || gameState.board[position] !== playerColor) return;
          visited.add(position);
          area.push(position);
          
          getAdjacentCells(position).forEach(adjPos => explore(adjPos));
        };
        
        explore(pos);
        if (area.length > 0) {
          areas.push({ positions: area, color: playerColor, size: area.length });
        }
      }
    }
  }
  
  return areas;
};

// ‡∏´‡∏≤‡∏û‡∏∑‡πâ‡∏ô‡∏ó‡∏µ‡πà‡πÄ‡∏ä‡∏∑‡πà‡∏≠‡∏°‡∏ï‡πà‡∏≠‡∏ó‡∏µ‡πà‡πÄ‡∏•‡πá‡∏Å‡∏ó‡∏µ‡πà‡∏™‡∏∏‡∏î‡∏Ç‡∏≠‡∏á‡∏ù‡∏±‡πà‡∏á‡∏ï‡∏£‡∏á‡∏Ç‡πâ‡∏≤‡∏°
const getSmallestOpponentArea = () => {
  const opponentColor = gameState.currentPlayer === 'black' ? 'white' : 'black';
  const allAreas = getAllConnectedAreas();
  const opponentAreas = allAreas.filter(area => area.color === opponentColor);
  
  if (opponentAreas.length === 0) return [];
  
  const smallestArea = opponentAreas.reduce((min, current) => 
    current.size < min.size ? current : min
  );
  
  return smallestArea.positions;
};

// ‡πÉ‡∏ä‡πâ Empty Set ‡∏Å‡∏±‡∏ö‡∏Å‡∏≤‡∏£‡πå‡∏î‡πÄ‡∏Ñ‡∏£‡∏∑‡πà‡∏≠‡∏á‡∏´‡∏°‡∏≤‡∏¢
const applyEmptySetWithMarker = (emptySetCard, markerCard) => {
  console.log('üéØ Debug: applyEmptySetWithMarker called with:', emptySetCard.label, '+', markerCard.label);
  const opponentColor = gameState.currentPlayer === 'black' ? 'white' : 'black';
  const playerName = getPlayerName(gameState.currentPlayer);
  
  // ‡∏´‡∏≤‡∏û‡∏∑‡πâ‡∏ô‡∏ó‡∏µ‡πà‡∏ó‡∏µ‡πà‡πÄ‡∏ä‡∏∑‡πà‡∏≠‡∏°‡∏ï‡πà‡∏≠‡∏Å‡∏±‡∏ô‡∏ó‡∏µ‡πà‡πÄ‡∏•‡πá‡∏Å‡∏ó‡∏µ‡πà‡∏™‡∏∏‡∏î‡∏Ç‡∏≠‡∏á‡∏ù‡∏±‡πà‡∏á‡∏ï‡∏£‡∏á‡∏Ç‡πâ‡∏≤‡∏°
  const smallestOpponentArea = getSmallestOpponentArea();
  
  if (smallestOpponentArea.length === 0) {
    showAlert('‡πÑ‡∏°‡πà‡∏°‡∏µ‡πÄ‡∏ö‡∏µ‡πâ‡∏¢‡∏Ç‡∏≠‡∏á‡∏ù‡∏±‡πà‡∏á‡∏ï‡∏£‡∏á‡∏Ç‡πâ‡∏≤‡∏°‡∏ö‡∏ô‡∏Å‡∏£‡∏∞‡∏î‡∏≤‡∏ô!', 'warning');
    
    // ‡∏•‡∏ö‡∏Å‡∏≤‡∏£‡πå‡∏î‡πÅ‡∏°‡πâ‡πÑ‡∏°‡πà‡∏™‡∏≥‡πÄ‡∏£‡πá‡∏à
    const setIndex = gameState.selectedCards.find(i => gameState.players[gameState.currentPlayer].hand[i].type === 'set');
    const markerIndex = gameState.selectedCards.find(i => gameState.players[gameState.currentPlayer].hand[i].type === 'marker');
    const allIndices = [setIndex, markerIndex].sort((a, b) => b - a);
    allIndices.forEach(index => gameState.players[gameState.currentPlayer].hand.splice(index, 1));
    
    gameState.selectedCards = [];
    updateDisplay();
    return;
  }
  
  let logMsg = `${playerName} ‡πÉ‡∏ä‡πâ ${emptySetCard.label} + ${markerCard.label} ‡∏Å‡∏±‡∏ö‡∏û‡∏∑‡πâ‡∏ô‡∏ó‡∏µ‡πà ${smallestOpponentArea.length} ‡∏ä‡πà‡∏≠‡∏á: ${smallestOpponentArea.join(', ')}`;
  
  switch(markerCard.subtype) {
    case 'union':
      // Union + Empty Set = ‡πÑ‡∏°‡πà‡πÄ‡∏Å‡∏¥‡∏î‡∏≠‡∏∞‡πÑ‡∏£
      logMsg += ' ‚Üí ‡πÑ‡∏°‡πà‡πÄ‡∏Å‡∏¥‡∏î‡∏Å‡∏≤‡∏£‡πÄ‡∏õ‡∏•‡∏µ‡πà‡∏¢‡∏ô‡πÅ‡∏õ‡∏•‡∏á (Union + Empty Set)';
      break;
      
    case 'intersection':
      // Intersection + Empty Set: ‡∏•‡∏ö‡πÄ‡∏â‡∏û‡∏≤‡∏∞‡πÄ‡∏ö‡∏µ‡πâ‡∏¢‡∏ù‡πà‡∏≤‡∏¢‡∏ï‡∏£‡∏á‡∏Ç‡πâ‡∏≤‡∏°‡∏ó‡∏±‡πâ‡∏á‡∏Å‡∏£‡∏∞‡∏î‡∏≤‡∏ô
      if (!setCard.cells || setCard.cells.length === 0) {
        const opponentColor = gameState.currentPlayer === 'black' ? 'white' : 'black';
        let removed = 0;
        for (let row = 0; row < 8; row++) {
          for (let col = 0; col < 8; col++) {
            const pos = `${String.fromCharCode(65 + row)}${col + 1}`;
            if (gameState.board[pos] === opponentColor) {
              delete gameState.board[pos];
              removed++;
              const cell = document.querySelector(`[data-position="${pos}"]`);
              if(cell) {
                cell.innerHTML = pos;
                cell.style.backgroundColor = 'white';
              }
            }
          }
        }
        updateTokenCounts();
        showToast(`‡∏•‡∏ö‡πÄ‡∏ö‡∏µ‡πâ‡∏¢‡∏ù‡πà‡∏≤‡∏¢‡∏ï‡∏£‡∏á‡∏Ç‡πâ‡∏≤‡∏°‡∏ó‡∏±‡πâ‡∏á‡∏Å‡∏£‡∏∞‡∏î‡∏≤‡∏ô ${removed} ‡∏ä‡πà‡∏≠‡∏á (Empty Set + Intersection)`, 'success');
        resultCells = [];
        // ‡∏•‡∏ö‡∏Å‡∏≤‡∏£‡πå‡∏î‡∏ó‡∏µ‡πà‡πÉ‡∏ä‡πâ‡∏ó‡∏±‡πâ‡∏á‡∏™‡∏≠‡∏á‡πÉ‡∏ö
        const setIndex = gameState.selectedCards.find(i => gameState.players[gameState.currentPlayer].hand[i].type === 'set');
        const markerIndex = gameState.selectedCards.find(i => gameState.players[gameState.currentPlayer].hand[i].type === 'marker');
        const allIndices = [setIndex, markerIndex].sort((a, b) => b - a);
        allIndices.forEach(index => gameState.players[gameState.currentPlayer].hand.splice(index, 1));
        gameState.selectedCards = [];
        gameState.cardsPlacedThisTurn.set = true;
        gameState.cardsPlacedThisTurn.marker = true;
        updateDisplay();
        updateGameStatus('‡∏Å‡∏î‡∏Ç‡πâ‡∏≤‡∏°‡πÄ‡∏ó‡∏¥‡∏£‡πå‡∏ô‡πÄ‡∏û‡∏∑‡πà‡∏≠‡∏à‡∏ö‡πÄ‡∏ó‡∏¥‡∏£‡πå‡∏ô');
        enableButtons(['skipTurnBtn']);
        return;
      } else {
        // Intersection: ‡πÑ‡∏î‡πâ‡πÄ‡∏â‡∏û‡∏≤‡∏∞‡∏û‡∏∑‡πâ‡∏ô‡∏ó‡∏µ‡πà‡∏ó‡∏µ‡πà‡∏°‡∏µ‡πÄ‡∏ö‡∏µ‡πâ‡∏¢‡∏≠‡∏¢‡∏π‡πà‡πÅ‡∏•‡πâ‡∏ß (‡∏ó‡∏±‡πâ‡∏á‡∏™‡∏≠‡∏á‡∏ù‡πà‡∏≤‡∏¢)
        const existingTokensInSet = setCard.cells.filter(pos => gameState.board[pos]);
        if (existingTokensInSet.length === 0) {
          showToast('‡πÑ‡∏°‡πà‡∏°‡∏µ‡πÄ‡∏ö‡∏µ‡πâ‡∏¢‡πÉ‡∏ô‡∏û‡∏∑‡πâ‡∏ô‡∏ó‡∏µ‡πà‡πÄ‡∏ã‡∏ï‡∏ô‡∏µ‡πâ‡∏ó‡∏µ‡πà‡∏à‡∏∞‡∏ó‡∏≥ Intersection ‡πÑ‡∏î‡πâ!', 'warning');
          // ‡∏•‡∏ö‡∏Å‡∏≤‡∏£‡πå‡∏î‡∏ó‡∏µ‡πà‡πÉ‡∏ä‡πâ‡∏ó‡∏±‡πâ‡∏á‡∏™‡∏≠‡∏á‡πÉ‡∏ö‡πÅ‡∏°‡πâ‡πÑ‡∏°‡πà‡∏™‡∏≥‡πÄ‡∏£‡πá‡∏à
          const setIndex = gameState.selectedCards.find(i => gameState.players[gameState.currentPlayer].hand[i].type === 'set');
          const markerIndex = gameState.selectedCards.find(i => gameState.players[gameState.currentPlayer].hand[i].type === 'marker');
          const allIndices = [setIndex, markerIndex].sort((a, b) => b - a);
          allIndices.forEach(index => gameState.players[gameState.currentPlayer].hand.splice(index, 1));
          gameState.selectedCards = [];
          updateDisplay();
          return;
        }
        resultCells = existingTokensInSet;
        console.log(`Intersection: ‡πÑ‡∏î‡πâ‡∏û‡∏∑‡πâ‡∏ô‡∏ó‡∏µ‡πà‡∏ó‡∏µ‡πà‡∏°‡∏µ‡πÄ‡∏ö‡∏µ‡πâ‡∏¢‡∏≠‡∏¢‡∏π‡πà‡πÅ‡∏•‡πâ‡∏ß ${resultCells.length} ‡∏ä‡πà‡∏≠‡∏á: ${resultCells.join(', ')}`);
      }
      break;
      
    case 'difference':
      // Difference + Empty Set = ‡πÑ‡∏°‡πà‡πÄ‡∏Å‡∏¥‡∏î‡∏≠‡∏∞‡πÑ‡∏£
      logMsg += ' ‚Üí ‡πÑ‡∏°‡πà‡πÄ‡∏Å‡∏¥‡∏î‡∏Å‡∏≤‡∏£‡πÄ‡∏õ‡∏•‡∏µ‡πà‡∏¢‡∏ô‡πÅ‡∏õ‡∏•‡∏á (Difference + Empty Set)';
      break;
      
    case 'complement':
      // üî• ‡πÅ‡∏Å‡πâ‡πÑ‡∏Ç: Complement + Empty Set = ‡∏¢‡∏∂‡∏î‡∏Ñ‡∏£‡∏≠‡∏á‡∏ó‡∏∏‡∏Å‡∏ä‡πà‡∏≠‡∏á‡∏ö‡∏ô‡∏Å‡∏£‡∏∞‡∏î‡∏≤‡∏ô (64 ‡∏ä‡πà‡∏≠‡∏á)
      console.log('üî• DEBUG: Complement + Empty Set - ‡∏¢‡∏∂‡∏î‡∏Ñ‡∏£‡∏≠‡∏á‡∏ó‡∏∏‡∏Å‡∏ä‡πà‡∏≠‡∏á‡∏ö‡∏ô‡∏Å‡∏£‡∏∞‡∏î‡∏≤‡∏ô');
      
      const allCells = [];
      for (let row = 0; row < 8; row++) {
        for (let col = 0; col < 8; col++) {
          allCells.push(`${String.fromCharCode(65 + row)}${col + 1}`);
        }
      }
      
      console.log('üî• DEBUG: Placing tokens on all', allCells.length, 'cells');
      
      allCells.forEach(pos => {
        gameState.board[pos] = gameState.currentPlayer;
        const cell = document.querySelector(`[data-position="${pos}"]`);
        if(cell) {
          const chip = document.createElement('div');
          chip.className = `chip ${gameState.currentPlayer}`;
          chip.textContent = gameState.currentPlayer === 'black' ? '‚ö´' : '‚ö™';
          cell.innerHTML = '';
          cell.appendChild(chip);
          cell.style.backgroundColor = gameState.currentPlayer === 'black' ? '#f3f4f6' : '#fef3c7';
        }
      });
      
      updateTokenCounts();
      logMsg += ` ‚Üí ‡∏¢‡∏∂‡∏î‡∏Ñ‡∏£‡∏≠‡∏á‡∏ó‡∏±‡πâ‡∏á‡∏Å‡∏£‡∏∞‡∏î‡∏≤‡∏ô ${allCells.length} ‡∏ä‡πà‡∏≠‡∏á! (Complement + Empty Set)`;
      showToast(`‡∏¢‡∏∂‡∏î‡∏Ñ‡∏£‡∏≠‡∏á‡∏ó‡∏±‡πâ‡∏á‡∏Å‡∏£‡∏∞‡∏î‡∏≤‡∏ô ${allCells.length} ‡∏ä‡πà‡∏≠‡∏á!`, 'success');
      break;
  }
  
  logMessage(logMsg);
  
  // ‡∏ï‡∏±‡πâ‡∏á‡∏Ñ‡πà‡∏≤‡∏™‡∏ñ‡∏≤‡∏ô‡∏∞
  gameState.cardsPlacedThisTurn.set = true;
  gameState.cardsPlacedThisTurn.marker = true;
  
  // ‡∏•‡∏ö‡∏Å‡∏≤‡∏£‡πå‡∏î‡∏ó‡∏µ‡πà‡πÉ‡∏ä‡πâ‡∏ó‡∏±‡πâ‡∏á‡∏™‡∏≠‡∏á‡πÉ‡∏ö
  console.log('üî• DEBUG: [EmptySet] About to remove cards from hand');
  console.log('üî• DEBUG: [EmptySet] Current hand size:', gameState.players[gameState.currentPlayer].hand.length);
  console.log('üî• DEBUG: [EmptySet] Selected cards:', gameState.selectedCards);
  
  const setIndex = gameState.selectedCards.find(i => gameState.players[gameState.currentPlayer].hand[i].type === 'set');
  const markerIndex = gameState.selectedCards.find(i => gameState.players[gameState.currentPlayer].hand[i].type === 'marker');
  
  console.log('üî• DEBUG: [EmptySet] Found setIndex:', setIndex);
  console.log('üî• DEBUG: [EmptySet] Found markerIndex:', markerIndex);
  
  if (setIndex === undefined || markerIndex === undefined) {
    console.error('üî• DEBUG: [EmptySet] Cannot find card indices!');
    console.log('üî• DEBUG: [EmptySet] Hand contents:', gameState.players[gameState.currentPlayer].hand.map(card => `${card.type}-${card.label}`));
    return;
  }
  
  const allIndices = [setIndex, markerIndex].sort((a, b) => b - a);
  console.log('üî• DEBUG: [EmptySet] Removing cards at indices:', allIndices);
  
  allIndices.forEach(index => {
    const card = gameState.players[gameState.currentPlayer].hand[index];
    if (card) {
      console.log('üî• DEBUG: [EmptySet] Removing card:', card.label, 'at index', index);
      gameState.players[gameState.currentPlayer].hand.splice(index, 1);
    } else {
      console.error('üî• DEBUG: [EmptySet] No card found at index', index);
    }
  });
  
  console.log('üî• DEBUG: [EmptySet] Hand size after removal:', gameState.players[gameState.currentPlayer].hand.length);
  
  gameState.selectedCards = [];
  updateDisplay();
  
  // ‡∏à‡∏ö‡πÄ‡∏ó‡∏¥‡∏£‡πå‡∏ô‡∏ó‡∏±‡∏ô‡∏ó‡∏µ
  setTimeout(() => {
    skipTurn();
  }, 1000);
  updateGameStatus('‡πÉ‡∏ä‡πâ Empty Set ‡πÅ‡∏•‡πâ‡∏ß - ‡∏à‡∏∞‡∏à‡∏ö‡πÄ‡∏ó‡∏¥‡∏£‡πå‡∏ô‡πÉ‡∏ô‡∏≠‡∏µ‡∏Å 1 ‡∏ß‡∏¥‡∏ô‡∏≤‡∏ó‡∏µ...');
  enableButtons([]);
};

// ‡∏™‡∏£‡πâ‡∏≤‡∏á‡∏Å‡∏£‡∏∞‡∏î‡∏≤‡∏ô
const createBoard = () => {
  const board = document.getElementById('gameBoard');
  board.innerHTML = '';
  
  const letters = ['A','B','C','D','E','F','G','H'];
  const numbers = ['1','2','3','4','5','6','7','8'];
  
  // ‡∏°‡∏∏‡∏°‡∏ã‡πâ‡∏≤‡∏¢‡∏ö‡∏ô
  const cornerCell = document.createElement('div');
  cornerCell.className = 'cell header';
  cornerCell.textContent = 'üéØ';
  board.appendChild(cornerCell);
  
  // ‡∏´‡∏±‡∏ß‡∏Ñ‡∏≠‡∏•‡∏±‡∏°‡∏ô‡πå
  numbers.forEach(num => {
    const cell = document.createElement('div');
    cell.className = 'cell header';
    cell.textContent = num;
    board.appendChild(cell);
  });
  
  // ‡πÅ‡∏ñ‡∏ß‡πÅ‡∏•‡∏∞‡πÄ‡∏ã‡∏•‡∏•‡πå‡πÄ‡∏Å‡∏°
  letters.forEach(letter => {
    // ‡∏´‡∏±‡∏ß‡πÅ‡∏ñ‡∏ß
    const rowHeader = document.createElement('div');
    rowHeader.className = 'cell header';
    rowHeader.textContent = letter;
    board.appendChild(rowHeader);
    
    // ‡πÄ‡∏ã‡∏•‡∏•‡πå‡πÄ‡∏Å‡∏°
    numbers.forEach(num => {
      const cell = document.createElement('div');
      cell.className = 'cell game-cell';
      cell.dataset.position = `${letter}${num}`;
      cell.textContent = `${letter}${num}`;
      board.appendChild(cell);
    });
  });
};

// ‡∏™‡∏∏‡πà‡∏°‡∏Å‡∏≤‡∏£‡πå‡∏î
const shuffleArray = (array) => {
  const newArray = [...array];
  for (let i = newArray.length - 1; i > 0; i--) {
    const j = Math.floor(Math.random() * (i + 1));
    [newArray[i], newArray[j]] = [newArray[j], newArray[i]];
  }
  return newArray;
};

// ‡∏´‡∏≤‡∏ä‡πà‡∏≠‡∏á‡∏ó‡∏µ‡πà‡∏≠‡∏¢‡∏π‡πà‡∏ï‡∏¥‡∏î‡∏Å‡∏±‡∏ô
const getAdjacentCells = (position) => {
  const letter = position.charAt(0);
  const number = parseInt(position.charAt(1));
  const adjacent = [];
  
  // ‡∏Ç‡∏∂‡πâ‡∏ô, ‡∏•‡∏á, ‡∏ã‡πâ‡∏≤‡∏¢, ‡∏Ç‡∏ß‡∏≤
  const directions = [
    { row: -1, col: 0 }, // ‡∏Ç‡∏∂‡πâ‡∏ô
    { row: 1, col: 0 },  // ‡∏•‡∏á
    { row: 0, col: -1 }, // ‡∏ã‡πâ‡∏≤‡∏¢
    { row: 0, col: 1 }   // ‡∏Ç‡∏ß‡∏≤
  ];
  
  const letterIndex = letter.charCodeAt(0) - 65; // A=0, B=1, ...
  
  directions.forEach(dir => {
    const newRow = letterIndex + dir.row;
    const newCol = number - 1 + dir.col; // number ‡πÄ‡∏õ‡πá‡∏ô 1-based
    
    if (newRow >= 0 && newRow <= 7 && newCol >= 0 && newCol <= 7) {
      const newLetter = String.fromCharCode(65 + newRow);
      const newNumber = newCol + 1;
      adjacent.push(`${newLetter}${newNumber}`);
    }
  });
  
  return adjacent;
};

// ‡∏´‡∏≤‡∏û‡∏∑‡πâ‡∏ô‡∏ó‡∏µ‡πà‡∏ó‡∏µ‡πà‡πÄ‡∏ä‡∏∑‡πà‡∏≠‡∏°‡∏ï‡πà‡∏≠‡∏Å‡∏±‡∏ô (Connected Components)
const getConnectedArea = (startPositions, playerColor) => {
  const visited = new Set();
  const connectedArea = new Set();
  
  const dfs = (position) => {
    if (visited.has(position) || connectedArea.has(position)) return;
    
    // ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡∏ß‡πà‡∏≤‡∏ä‡πà‡∏≠‡∏á‡∏ô‡∏µ‡πâ‡∏°‡∏µ‡πÄ‡∏ö‡∏µ‡πâ‡∏¢‡∏Ç‡∏≠‡∏á‡∏ú‡∏π‡πâ‡πÄ‡∏•‡πà‡∏ô‡∏´‡∏£‡∏∑‡∏≠‡πÑ‡∏°‡πà
    if (!gameState.board[position] || gameState.board[position] !== playerColor) {
      return;
    }
    
    visited.add(position);
    connectedArea.add(position);
    
    // ‡∏Ñ‡πâ‡∏ô‡∏´‡∏≤‡∏ä‡πà‡∏≠‡∏á‡∏ï‡∏¥‡∏î‡∏Å‡∏±‡∏ô‡∏ó‡∏µ‡πà‡∏°‡∏µ‡πÄ‡∏ö‡∏µ‡πâ‡∏¢‡∏™‡∏µ‡πÄ‡∏î‡∏µ‡∏¢‡∏ß‡∏Å‡∏±‡∏ô
    const adjacent = getAdjacentCells(position);
    adjacent.forEach(adjPos => {
      if (gameState.board[adjPos] === playerColor) {
        dfs(adjPos);
      }
    });
  };
  
  // ‡πÄ‡∏£‡∏¥‡πà‡∏°‡∏Ñ‡πâ‡∏ô‡∏´‡∏≤‡∏à‡∏≤‡∏Å‡∏ó‡∏∏‡∏Å‡∏ï‡∏≥‡πÅ‡∏´‡∏ô‡πà‡∏á‡πÄ‡∏£‡∏¥‡πà‡∏°‡∏ï‡πâ‡∏ô
  startPositions.forEach(pos => {
    if (gameState.board[pos] === playerColor) {
      dfs(pos);
    }
  });
  
  return Array.from(connectedArea);
};

// ‡πÄ‡∏£‡∏¥‡πà‡∏°‡πÄ‡∏Å‡∏°‡πÉ‡∏´‡∏°‡πà

// ‡∏ü‡∏±‡∏á‡∏Å‡πå‡∏ä‡∏±‡∏ô‡πÄ‡∏õ‡∏•‡∏µ‡πà‡∏¢‡∏ô‡∏Å‡∏≤‡∏£‡πå‡∏î‡∏à‡∏≤‡∏Å‡∏Å‡∏≠‡∏á (‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö pregame phase)
const changeCardFromDeck = () => {
  const cardIndex = gameState.selectedCards[0];
  const oldCard = gameState.players[gameState.currentPlayer].hand[cardIndex];
  
  // ‡πÉ‡∏™‡πà‡∏Å‡∏≤‡∏£‡πå‡∏î‡πÄ‡∏Å‡πà‡∏≤‡∏Å‡∏•‡∏±‡∏ö‡πÑ‡∏õ‡∏ó‡∏µ‡πà‡∏î‡πâ‡∏≤‡∏ô‡∏•‡πà‡∏≤‡∏á‡∏Ç‡∏≠‡∏á‡∏Å‡∏≠‡∏á
  gameState.deckSet.unshift(oldCard);
  
  // ‡∏à‡∏±‡πà‡∏ß‡∏Å‡∏≤‡∏£‡πå‡∏î‡πÉ‡∏´‡∏°‡πà‡∏à‡∏≤‡∏Å‡∏î‡πâ‡∏≤‡∏ô‡∏ö‡∏ô
  if(gameState.deckSet.length > 1) {
    const newCard = gameState.deckSet.pop();
    gameState.players[gameState.currentPlayer].hand[cardIndex] = newCard;
    
    const playerName = getPlayerName(gameState.currentPlayer);
    logMessage(`${playerName} ‡πÄ‡∏õ‡∏•‡∏µ‡πà‡∏¢‡∏ô‡∏Å‡∏≤‡∏£‡πå‡∏î: ${oldCard.label} ‚Üí ${newCard.label} (‡∏´‡∏•‡∏µ‡∏Å‡πÄ‡∏•‡∏µ‡πà‡∏¢‡∏á‡∏Å‡∏≤‡∏£‡∏ã‡πâ‡∏≥)`);
    
    // ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡∏Å‡∏≤‡∏£‡πå‡∏î‡πÉ‡∏´‡∏°‡πà‡∏ß‡πà‡∏≤‡∏ã‡πâ‡∏≥‡∏´‡∏£‡∏∑‡∏≠‡πÑ‡∏°‡πà
    const conflicts = newCard.cells.filter(pos => gameState.board[pos]);
    if(conflicts.length > 0) {
      // ‡∏¢‡∏±‡∏á‡∏ã‡πâ‡∏≥‡∏≠‡∏¢‡∏π‡πà ‡πÉ‡∏´‡πâ‡πÄ‡∏õ‡∏•‡∏µ‡πà‡∏¢‡∏ô‡∏≠‡∏µ‡∏Å‡∏Ñ‡∏£‡∏±‡πâ‡∏á
      // ‡∏ú‡∏π‡πâ‡πÄ‡∏•‡πà‡∏ô‡∏Ñ‡∏ô‡πÄ‡∏•‡∏∑‡∏≠‡∏Å
      const continueChange = confirm(`‡∏Å‡∏≤‡∏£‡πå‡∏î‡πÉ‡∏´‡∏°‡πà‡∏¢‡∏±‡∏á‡∏ã‡πâ‡∏≥‡∏Å‡∏±‡∏ö‡∏ú‡∏π‡πâ‡πÄ‡∏•‡πà‡∏ô‡πÅ‡∏£‡∏Å‡∏≠‡∏¢‡∏π‡πà‡∏ó‡∏µ‡πà: ${conflicts.join(', ')}\n\n‡∏ï‡πâ‡∏≠‡∏á‡∏Å‡∏≤‡∏£‡πÄ‡∏õ‡∏•‡∏µ‡πà‡∏¢‡∏ô‡∏Å‡∏≤‡∏£‡πå‡∏î‡πÉ‡∏´‡∏°‡πà‡∏≠‡∏µ‡∏Å‡∏Ñ‡∏£‡∏±‡πâ‡∏á‡∏´‡∏£‡∏∑‡∏≠‡πÑ‡∏°‡πà?`);
      
      if(continueChange && gameState.deckSet.length > 1) {
        changeCardFromDeck();
        return;
      } else {
        // ‡πÉ‡∏´‡πâ‡πÄ‡∏•‡∏∑‡∏≠‡∏Å‡∏Å‡∏≤‡∏£‡πå‡∏î‡∏≠‡∏∑‡πà‡∏ô‡∏à‡∏≤‡∏Å‡∏°‡∏∑‡∏≠
        showAlert('‡∏Å‡∏£‡∏∏‡∏ì‡∏≤‡πÄ‡∏•‡∏∑‡∏≠‡∏Å‡∏Å‡∏≤‡∏£‡πå‡∏î‡∏≠‡∏∑‡πà‡∏ô‡∏à‡∏≤‡∏Å‡∏°‡∏∑‡∏≠ ‡∏´‡∏£‡∏∑‡∏≠‡πÄ‡∏õ‡∏•‡∏µ‡πà‡∏¢‡∏ô‡∏Å‡∏≤‡∏£‡πå‡∏î‡πÉ‡∏´‡∏°‡πà‡∏≠‡∏µ‡∏Å‡∏Ñ‡∏£‡∏±‡πâ‡∏á', 'info');
        gameState.selectedCards = [];
        updateDisplay();
        return;
      }
    } else {
      // ‡∏Å‡∏≤‡∏£‡πå‡∏î‡πÉ‡∏´‡∏°‡πà‡πÑ‡∏°‡πà‡∏ã‡πâ‡∏≥ ‡πÉ‡∏ä‡πâ‡πÑ‡∏î‡πâ
      gameState.selectedCards = [cardIndex];
      updateDisplay();
      
      // ‡πÅ‡∏™‡∏î‡∏á‡∏Ç‡πâ‡∏≠‡∏Ñ‡∏ß‡∏≤‡∏°‡πÅ‡∏ô‡∏∞‡∏ô‡∏≥‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡∏ú‡∏π‡πâ‡πÄ‡∏•‡πà‡∏ô
      updateGameStatus('‡∏Å‡∏≤‡∏£‡πå‡∏î‡πÉ‡∏´‡∏°‡πà‡πÑ‡∏°‡πà‡∏ã‡πâ‡∏≥‡πÅ‡∏•‡πâ‡∏ß - ‡∏Å‡∏î‡∏ß‡∏≤‡∏á‡∏Å‡∏≤‡∏£‡πå‡∏î‡πÄ‡∏û‡∏∑‡πà‡∏≠‡∏î‡∏≥‡πÄ‡∏ô‡∏¥‡∏ô‡∏Å‡∏≤‡∏£‡∏ï‡πà‡∏≠');
      enableButtons(['placeCardsBtn']);
    }
  } else {
    showAlert('‡πÑ‡∏°‡πà‡∏°‡∏µ‡∏Å‡∏≤‡∏£‡πå‡∏î‡πÉ‡∏ô‡∏Å‡∏≠‡∏á‡πÉ‡∏´‡πâ‡πÄ‡∏õ‡∏•‡∏µ‡πà‡∏¢‡∏ô!', 'warning');
  }
};

// ‡∏ü‡∏±‡∏á‡∏Å‡πå‡∏ä‡∏±‡∏ô‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡πÅ‡∏™‡∏î‡∏á‡∏ä‡∏∑‡πà‡∏≠‡∏ú‡∏π‡πâ‡πÄ‡∏•‡πà‡∏ô
const getPlayerName = (color) => {
  return color === 'black' ? '‡∏ú‡∏π‡πâ‡πÄ‡∏•‡πà‡∏ô 1 (‡∏î‡∏≥)' : '‡∏ú‡∏π‡πâ‡πÄ‡∏•‡πà‡∏ô 2 (‡∏Ç‡∏≤‡∏ß)';
};

const startNewGame = () => {
  console.log('üéÆ Debug: startNewGame called');
  
  // ‡πÄ‡∏£‡∏¥‡πà‡∏°‡πÄ‡∏Å‡∏°‡πÇ‡∏´‡∏°‡∏î 2 ‡∏ú‡∏π‡πâ‡πÄ‡∏•‡πà‡∏ô‡πÇ‡∏î‡∏¢‡∏ï‡∏£‡∏á
  gameState = {
    phase: 'pregame',
    turn: 0,
    currentPlayer: 'black',
    players: {
      black: { hand: [], score: 0, tokens: 0 },
      white: { hand: [], score: 0, tokens: 0 }
    },
    board: {},
    deckSet: shuffleArray([...generate2x2Cards(), ...generate4x4Cards(), ...generateEmptySetCards()]),
    deckMarker: shuffleArray(generateMarkerCards()),
    drawnThisTurn: false,
    cardsPlacedThisTurn: { set: false, marker: false },
    selectedCards: []
  };
  
  // ‡πÅ‡∏à‡∏Å‡∏Å‡∏≤‡∏£‡πå‡∏î‡πÄ‡∏£‡∏¥‡πà‡∏°‡∏ï‡πâ‡∏ô (‡∏Å‡∏≤‡∏£‡πå‡∏î‡πÄ‡∏ã‡∏ï‡∏Ñ‡∏ô‡∏•‡∏∞ 2 ‡πÉ‡∏ö)
  for(let i = 0; i < 2; i++) {
    gameState.players.black.hand.push(gameState.deckSet.pop());
    gameState.players.white.hand.push(gameState.deckSet.pop());
  }
  
  clearBoard();
  updateDisplay();
  
  logMessage('üéÆ ‡πÄ‡∏£‡∏¥‡πà‡∏°‡πÄ‡∏Å‡∏°‡πÉ‡∏´‡∏°‡πà! ‡∏ú‡∏π‡πâ‡πÄ‡∏•‡πà‡∏ô 1 (‡∏î‡∏≥) vs ‡∏ú‡∏π‡πâ‡πÄ‡∏•‡πà‡∏ô 2 (‡∏Ç‡∏≤‡∏ß)');
  logMessage('üìù ‡πÉ‡∏´‡πâ‡∏ú‡∏π‡πâ‡πÄ‡∏•‡πà‡∏ô‡∏î‡∏≥‡∏•‡∏á‡∏Å‡∏≤‡∏£‡πå‡∏î‡πÄ‡∏ã‡∏ï 1 ‡πÉ‡∏ö‡∏Å‡πà‡∏≠‡∏ô (‡∏ï‡πâ‡∏≠‡∏á‡πÑ‡∏°‡πà‡∏ã‡πâ‡∏≥‡∏Å‡∏±‡∏ö‡∏ú‡∏π‡πâ‡πÄ‡∏•‡πà‡∏ô‡∏Ç‡∏≤‡∏ß)');
  
  updateGameStatus('‡∏ú‡∏π‡πâ‡πÄ‡∏•‡πà‡∏ô 1 (‡∏î‡∏≥): ‡πÄ‡∏•‡∏∑‡∏≠‡∏Å‡∏Å‡∏≤‡∏£‡πå‡∏î‡πÄ‡∏ã‡∏ï 1 ‡πÉ‡∏ö‡πÄ‡∏û‡∏∑‡πà‡∏≠‡∏ß‡∏≤‡∏á‡πÄ‡∏ö‡∏µ‡πâ‡∏¢‡πÄ‡∏£‡∏¥‡πà‡∏°‡∏ï‡πâ‡∏ô');
  enableButtons(['placeCardsBtn']);
};

// ‡∏•‡πâ‡∏≤‡∏á‡∏Å‡∏£‡∏∞‡∏î‡∏≤‡∏ô
const clearBoard = () => {
  gameState.board = {};
  const cells = document.querySelectorAll('.game-cell');
  cells.forEach(cell => {
    cell.innerHTML = cell.dataset.position;
    cell.style.backgroundColor = 'white';
  });
};

// ‡∏ß‡∏≤‡∏á‡πÄ‡∏ö‡∏µ‡πâ‡∏¢‡∏ö‡∏ô‡∏Å‡∏£‡∏∞‡∏î‡∏≤‡∏ô
const placeTokens = (positions, player) => {
  console.log(`Placing tokens for ${player} at positions:`, positions);
  
  try {
    positions.forEach(pos => {
      gameState.board[pos] = player;
      const cell = document.querySelector(`[data-position="${pos}"]`);
      if(cell) {
        const chip = document.createElement('div');
        chip.className = `chip ${player}`;
        chip.textContent = player === 'black' ? '‚ö´' : '‚ö™';
        cell.innerHTML = '';
        cell.appendChild(chip);
        
        // ‡πÄ‡∏û‡∏¥‡πà‡∏°‡∏™‡∏µ‡∏û‡∏∑‡πâ‡∏ô‡∏´‡∏•‡∏±‡∏á‡πÄ‡∏•‡πá‡∏Å‡∏ô‡πâ‡∏≠‡∏¢‡πÄ‡∏û‡∏∑‡πà‡∏≠‡πÅ‡∏™‡∏î‡∏á‡∏Å‡∏≤‡∏£‡∏Ñ‡∏£‡∏≠‡∏ö‡∏Ñ‡∏£‡∏≠‡∏á
        cell.style.backgroundColor = player === 'black' ? '#f3f4f6' : '#fef3c7';
      } else {
        console.error(`Cannot find cell for position: ${pos}`);
        throw new Error(`‡πÑ‡∏°‡πà‡∏û‡∏ö‡∏ä‡πà‡∏≠‡∏á‡∏ó‡∏µ‡πà‡∏ï‡∏≥‡πÅ‡∏´‡∏ô‡πà‡∏á ${pos}`);
      }
    });
    updateTokenCounts();
    console.log(`Successfully placed ${positions.length} tokens for ${player}`);
  } catch (error) {
    console.error('Error in placeTokens:', error);
    throw error; // Re-throw ‡πÄ‡∏û‡∏∑‡πà‡∏≠‡πÉ‡∏´‡πâ caller ‡∏à‡∏±‡∏î‡∏Å‡∏≤‡∏£‡∏ï‡πà‡∏≠
  }
};

// ‡∏ô‡∏±‡∏ö‡∏à‡∏≥‡∏ô‡∏ß‡∏ô‡πÄ‡∏ö‡∏µ‡πâ‡∏¢
const updateTokenCounts = () => {
  gameState.players.black.tokens = Object.values(gameState.board).filter(p => p === 'black').length;
  gameState.players.white.tokens = Object.values(gameState.board).filter(p => p === 'white').length;
};

// ‡∏Ñ‡∏≥‡∏ô‡∏ß‡∏ì‡∏Ñ‡∏∞‡πÅ‡∏ô‡∏ô
const calculateScore = (player) => {
  return gameState.players[player].tokens - gameState.players[player].hand.length;
};

// ‡∏≠‡∏±‡∏û‡πÄ‡∏î‡∏ó‡∏Å‡∏≤‡∏£‡πÅ‡∏™‡∏î‡∏á‡∏ú‡∏•
const updateDisplay = () => {
  // ‡∏≠‡∏±‡∏û‡πÄ‡∏î‡∏ó‡∏Ñ‡∏∞‡πÅ‡∏ô‡∏ô
  document.getElementById('blackScore').textContent = `${calculateScore('black')} ‡∏Ñ‡∏∞‡πÅ‡∏ô‡∏ô (‡πÄ‡∏ö‡∏µ‡πâ‡∏¢: ${gameState.players.black.tokens}, ‡∏Å‡∏≤‡∏£‡πå‡∏î: ${gameState.players.black.hand.length})`;
  document.getElementById('whiteScore').textContent = `${calculateScore('white')} ‡∏Ñ‡∏∞‡πÅ‡∏ô‡∏ô (‡πÄ‡∏ö‡∏µ‡πâ‡∏¢: ${gameState.players.white.tokens}, ‡∏Å‡∏≤‡∏£‡πå‡∏î: ${gameState.players.white.hand.length})`;
  
  // ‡∏≠‡∏±‡∏û‡πÄ‡∏î‡∏ó‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡πÄ‡∏ó‡∏¥‡∏£‡πå‡∏ô
  const turnInfo = document.getElementById('turnInfo');
  turnInfo.className = 'turn-info'; // ‡∏£‡∏µ‡πÄ‡∏ã‡πá‡∏ï class
  
  if(gameState.phase === 'playing') {
    const playerName = gameState.currentPlayer === 'black' ? '‡∏ú‡∏π‡πâ‡πÄ‡∏•‡πà‡∏ô‡∏î‡∏≥' : '‡∏ú‡∏π‡πâ‡πÄ‡∏•‡πà‡∏ô‡∏Ç‡∏≤‡∏ß';
    const playerIcon = gameState.currentPlayer === 'black' ? '‚ö´' : '‚ö™';
    turnInfo.className = `turn-info ${gameState.currentPlayer}-turn active`;
    turnInfo.innerHTML = `
      <div class="current-player-indicator">
        <span>${playerIcon}</span>
        <span>‡πÄ‡∏ó‡∏¥‡∏£‡πå‡∏ô‡∏ó‡∏µ‡πà ${gameState.turn}/20 - ${playerName}</span>
      </div>
    `;
  } else if(gameState.phase === 'pregame') {
    const playerName = gameState.currentPlayer === 'black' ? '‡∏ú‡∏π‡πâ‡πÄ‡∏•‡πà‡∏ô‡∏î‡∏≥' : '‡∏ú‡∏π‡πâ‡πÄ‡∏•‡πà‡∏ô‡∏Ç‡∏≤‡∏ß';
    const playerIcon = gameState.currentPlayer === 'black' ? '‚ö´' : '‚ö™';
    turnInfo.className = `turn-info ${gameState.currentPlayer}-turn active`;
    turnInfo.innerHTML = `
      <div class="current-player-indicator">
        <span>${playerIcon}</span>
        <span>‡πÄ‡∏ï‡∏£‡∏µ‡∏¢‡∏°‡πÄ‡∏£‡∏¥‡πà‡∏°‡πÄ‡∏Å‡∏° - ${playerName} ‡∏ß‡∏≤‡∏á‡πÄ‡∏ö‡∏µ‡πâ‡∏¢‡πÄ‡∏£‡∏¥‡πà‡∏°‡∏ï‡πâ‡∏ô</span>
      </div>
    `;
  } else if(gameState.phase === 'finished') {
    const blackScore = calculateScore('black');
    const whiteScore = calculateScore('white');
    const winner = blackScore > whiteScore ? '‡∏ú‡∏π‡πâ‡πÄ‡∏•‡πà‡∏ô‡∏î‡∏≥' : blackScore < whiteScore ? '‡∏ú‡∏π‡πâ‡πÄ‡∏•‡πà‡∏ô‡∏Ç‡∏≤‡∏ß' : '‡πÄ‡∏™‡∏°‡∏≠';
    turnInfo.className = 'turn-info';
    turnInfo.textContent = `üèÅ ‡∏à‡∏ö‡πÄ‡∏Å‡∏°! ‡∏ú‡∏π‡πâ‡∏ä‡∏ô‡∏∞: ${winner}`;
  } else {
    turnInfo.className = 'turn-info';
    turnInfo.textContent = '‡∏Å‡∏î‡πÄ‡∏£‡∏¥‡πà‡∏°‡πÄ‡∏Å‡∏°‡πÉ‡∏´‡∏°‡πà‡πÄ‡∏û‡∏∑‡πà‡∏≠‡πÄ‡∏•‡πà‡∏ô';
  }
  
  // ‡∏≠‡∏±‡∏û‡πÄ‡∏î‡∏ó‡∏Å‡∏≤‡∏£‡πå‡∏î‡πÉ‡∏ô‡∏°‡∏∑‡∏≠
  updatePlayerHand();
  
  // ‡∏≠‡∏±‡∏û‡πÄ‡∏î‡∏ó‡∏Å‡∏≤‡∏£‡∏ô‡∏±‡∏ö‡∏Å‡∏≤‡∏£‡πå‡∏î‡∏Ñ‡∏á‡πÄ‡∏´‡∏•‡∏∑‡∏≠
  updateCardCounts();
};

// ‡πÅ‡∏™‡∏î‡∏á‡∏Å‡∏≤‡∏£‡πå‡∏î‡πÉ‡∏ô‡∏°‡∏∑‡∏≠
const updatePlayerHand = () => {
  const handDiv = document.getElementById('playerHand');
  handDiv.innerHTML = '';
  
  if(gameState.phase === 'waiting') return;
  
  const currentHand = gameState.players[gameState.currentPlayer].hand;
  currentHand.forEach((card, index) => {
    const cardElement = document.createElement('div');
    cardElement.className = `card ${card.type}`;
    cardElement.onclick = () => selectCard(index);
    
    // ‡∏™‡∏£‡πâ‡∏≤‡∏á‡∏Ç‡πâ‡∏≠‡∏Ñ‡∏ß‡∏≤‡∏°‡∏´‡∏•‡∏±‡∏Å
    const labelDiv = document.createElement('div');
    labelDiv.textContent = card.label;
    cardElement.appendChild(labelDiv);
    
    // ‡πÅ‡∏™‡∏î‡∏á‡∏£‡∏≤‡∏¢‡∏•‡∏∞‡πÄ‡∏≠‡∏µ‡∏¢‡∏î‡∏û‡∏∑‡πâ‡∏ô‡∏ó‡∏µ‡πà‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡∏Å‡∏≤‡∏£‡πå‡∏î‡πÄ‡∏ã‡∏ï
    if(card.type === 'set' && card.cells) {
      const detailsDiv = document.createElement('div');
      detailsDiv.className = 'card-details';
      detailsDiv.textContent = `‡∏û‡∏∑‡πâ‡∏ô‡∏ó‡∏µ‡πà: ${card.cells.join(', ')}`;
      cardElement.appendChild(detailsDiv);
    }
    
    cardElement.dataset.index = index;
    
    if(gameState.selectedCards.includes(index)) {
      cardElement.classList.add('selected');
    }
    
    handDiv.appendChild(cardElement);
  });
};

// ‡πÄ‡∏•‡∏∑‡∏≠‡∏Å‡∏Å‡∏≤‡∏£‡πå‡∏î
const selectCard = (index) => {
  console.log('üë§ DEBUG: [HUMAN] selectCard called with index:', index);
  console.log('üë§ DEBUG: [HUMAN] Current selectedCards before:', [...gameState.selectedCards]);
  console.log('üë§ DEBUG: [HUMAN] Current player:', gameState.currentPlayer);
  console.log('üë§ DEBUG: [HUMAN] Game phase:', gameState.phase, 'Turn phase:', gameState.turnPhase);
  
  const cardIndex = gameState.selectedCards.indexOf(index);
  if(cardIndex === -1) {
    gameState.selectedCards.push(index);
    console.log('üë§ DEBUG: [HUMAN] Added card index', index, 'to selection');
  } else {
    gameState.selectedCards.splice(cardIndex, 1);
    console.log('üë§ DEBUG: [HUMAN] Removed card index', index, 'from selection');
  }
  
  console.log('üë§ DEBUG: [HUMAN] selectedCards after:', [...gameState.selectedCards]);
  console.log('üë§ DEBUG: [HUMAN] Selected cards count:', gameState.selectedCards.length);
  updatePlayerHand();
};

// ‡πÄ‡∏õ‡∏¥‡∏î/‡∏õ‡∏¥‡∏î‡∏õ‡∏∏‡πà‡∏°
const enableButtons = (buttons) => {
  const allButtons = ['drawSetBtn', 'drawMarkerBtn', 'placeCardsBtn', 'discardBtn', 'skipTurnBtn'];
  allButtons.forEach(id => {
    const btn = document.getElementById(id);
    if (btn) {
      btn.disabled = !buttons.includes(id);
      // ‡∏õ‡∏¥‡∏î loading state ‡∏ñ‡πâ‡∏≤‡∏°‡∏µ
      if (btn.classList.contains('loading')) {
        btn.classList.remove('loading');
      }
    }
  });
  
  // Debug: log ‡∏™‡∏ñ‡∏≤‡∏ô‡∏∞‡∏õ‡∏∏‡πà‡∏°
  console.log('üéÆ Debug: enableButtons called with:', buttons, 'Phase:', gameState.phase, 'TurnPhase:', gameState.turnPhase);
};

// ‡∏≠‡∏±‡∏û‡πÄ‡∏î‡∏ó‡∏™‡∏ñ‡∏≤‡∏ô‡∏∞‡πÄ‡∏Å‡∏°
const updateGameStatus = (message) => {
  document.getElementById('gameStatus').textContent = message;
};

// ‡∏ö‡∏±‡∏ô‡∏ó‡∏∂‡∏Å‡∏Ç‡πâ‡∏≠‡∏Ñ‡∏ß‡∏≤‡∏°
const logMessage = (message) => {
  const logDiv = document.getElementById('gameLog');
  const entry = document.createElement('div');
  entry.className = 'log-entry';
  entry.textContent = message;
  logDiv.appendChild(entry);
  logDiv.scrollTop = logDiv.scrollHeight;
};

// ‡∏à‡∏±‡πà‡∏ß‡∏Å‡∏≤‡∏£‡πå‡∏î‡πÄ‡∏ã‡∏ï
const drawSetCard = () => {
  if(gameState.drawnThisTurn) {
    alert('‡∏Ñ‡∏∏‡∏ì‡πÑ‡∏î‡πâ‡∏à‡∏±‡πà‡∏ß‡∏Å‡∏≤‡∏£‡πå‡∏î‡πÉ‡∏ô‡πÄ‡∏ó‡∏¥‡∏£‡πå‡∏ô‡∏ô‡∏µ‡πâ‡πÅ‡∏•‡πâ‡∏ß!');
    return;
  }
  
  if(gameState.deckSet.length === 0) {
    alert('‡∏Å‡∏≠‡∏á‡∏Å‡∏≤‡∏£‡πå‡∏î‡πÄ‡∏ã‡∏ï‡∏´‡∏°‡∏î‡πÅ‡∏•‡πâ‡∏ß!');
    return;
  }
  
  const card = gameState.deckSet.pop();
  gameState.players[gameState.currentPlayer].hand.push(card);
  
  const playerName = getPlayerName(gameState.currentPlayer);
  logMessage(`${playerName} ‡∏à‡∏±‡πà‡∏ß‡∏Å‡∏≤‡∏£‡πå‡∏î‡πÄ‡∏ã‡∏ï: ${card.label} (${card.cells.join(', ')})`);
  
  // ‡∏à‡∏±‡πà‡∏ß‡∏Å‡∏≤‡∏£‡πå‡∏î‡πÅ‡∏•‡πâ‡∏ß‡πÄ‡∏Ç‡πâ‡∏≤‡∏™‡∏π‡πà‡∏Ç‡∏±‡πâ‡∏ô‡∏ï‡∏≠‡∏ô‡πÄ‡∏•‡∏∑‡∏≠‡∏Å‡πÉ‡∏ä‡πâ‡∏™‡∏¥‡∏ó‡∏ò‡∏¥‡πå
  gameState.drawnThisTurn = true;
  gameState.turnPhase = 'action';
  updateDisplay();
  
  updateGameStatus('‡πÄ‡∏•‡∏∑‡∏≠‡∏Å‡πÉ‡∏ä‡πâ‡∏™‡∏¥‡∏ó‡∏ò‡∏¥‡πå: ‡∏•‡∏á‡∏Å‡∏≤‡∏£‡πå‡∏î (‡∏™‡∏π‡∏á‡∏™‡∏∏‡∏î 2 ‡πÉ‡∏ö ‡∏õ‡∏£‡∏∞‡πÄ‡∏†‡∏ó‡∏•‡∏∞ 1 ‡πÉ‡∏ö), ‡∏ó‡∏¥‡πâ‡∏á‡∏Å‡∏≤‡∏£‡πå‡∏î (1 ‡πÉ‡∏ö), ‡∏´‡∏£‡∏∑‡∏≠‡∏Ç‡πâ‡∏≤‡∏°‡πÄ‡∏ó‡∏¥‡∏£‡πå‡∏ô');
  enableButtons(['placeCardsBtn', 'discardBtn', 'skipTurnBtn']);
};

// ‡∏à‡∏±‡πà‡∏ß‡∏Å‡∏≤‡∏£‡πå‡∏î‡πÄ‡∏Ñ‡∏£‡∏∑‡πà‡∏≠‡∏á‡∏´‡∏°‡∏≤‡∏¢
const drawMarkerCard = () => {
  if(gameState.drawnThisTurn) {
    alert('‡∏Ñ‡∏∏‡∏ì‡πÑ‡∏î‡πâ‡∏à‡∏±‡πà‡∏ß‡∏Å‡∏≤‡∏£‡πå‡∏î‡πÉ‡∏ô‡πÄ‡∏ó‡∏¥‡∏£‡πå‡∏ô‡∏ô‡∏µ‡πâ‡πÅ‡∏•‡πâ‡∏ß!');
    return;
  }
  
  if(gameState.deckMarker.length === 0) {
    alert('‡∏Å‡∏≠‡∏á‡∏Å‡∏≤‡∏£‡πå‡∏î‡πÄ‡∏Ñ‡∏£‡∏∑‡πà‡∏≠‡∏á‡∏´‡∏°‡∏≤‡∏¢‡∏´‡∏°‡∏î‡πÅ‡∏•‡πâ‡∏ß!');
    return;
  }
  
  let card = gameState.deckMarker.pop();
  
  // ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡∏Å‡∏é‡πÄ‡∏ó‡∏¥‡∏£‡πå‡∏ô‡∏ó‡∏µ‡πà 16+ ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö Union
  // ‡πÑ‡∏°‡πà‡∏°‡∏µ‡∏Ç‡πâ‡∏≠‡∏à‡∏≥‡∏Å‡∏±‡∏î‡∏Å‡∏≤‡∏£‡πÉ‡∏ä‡πâ Union
  
  // ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡∏Å‡∏é Complement (‡πÉ‡∏ä‡πâ‡πÑ‡∏î‡πâ‡∏ï‡∏±‡πâ‡∏á‡πÅ‡∏ï‡πà‡πÄ‡∏ó‡∏¥‡∏£‡πå‡∏ô‡∏ó‡∏µ‡πà 10)
  // ‡πÑ‡∏°‡πà‡∏°‡∏µ‡∏Ç‡πâ‡∏≠‡∏à‡∏≥‡∏Å‡∏±‡∏î‡∏Å‡∏≤‡∏£‡πÉ‡∏ä‡πâ Complement
    // ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡∏ã‡πâ‡∏≥‡∏ñ‡πâ‡∏≤‡∏Å‡∏≤‡∏£‡πå‡∏î‡πÉ‡∏´‡∏°‡πà‡∏¢‡∏±‡∏á‡πÄ‡∏õ‡πá‡∏ô Complement
    if(card.subtype === 'complement' && gameState.turn < 10) {
  // ‡πÑ‡∏°‡πà‡∏°‡∏µ‡∏Ç‡πâ‡∏≠‡∏à‡∏≥‡∏Å‡∏±‡∏î‡∏Å‡∏≤‡∏£‡πÉ‡∏ä‡πâ Complement
  }
  
  gameState.players[gameState.currentPlayer].hand.push(card);
  
  const playerName = getPlayerName(gameState.currentPlayer);
  logMessage(`${playerName} ‡∏à‡∏±‡πà‡∏ß‡∏Å‡∏≤‡∏£‡πå‡∏î‡πÄ‡∏Ñ‡∏£‡∏∑‡πà‡∏≠‡∏á‡∏´‡∏°‡∏≤‡∏¢: ${card.label}`);
  
  // ‡∏à‡∏±‡πà‡∏ß‡∏Å‡∏≤‡∏£‡πå‡∏î‡πÅ‡∏•‡πâ‡∏ß‡πÄ‡∏Ç‡πâ‡∏≤‡∏™‡∏π‡πà‡∏Ç‡∏±‡πâ‡∏ô‡∏ï‡∏≠‡∏ô‡πÄ‡∏•‡∏∑‡∏≠‡∏Å‡πÉ‡∏ä‡πâ‡∏™‡∏¥‡∏ó‡∏ò‡∏¥‡πå
  gameState.drawnThisTurn = true;
  gameState.turnPhase = 'action';
  updateDisplay();
  
  updateGameStatus('‡πÄ‡∏•‡∏∑‡∏≠‡∏Å‡πÉ‡∏ä‡πâ‡∏™‡∏¥‡∏ó‡∏ò‡∏¥‡πå: ‡∏•‡∏á‡∏Å‡∏≤‡∏£‡πå‡∏î (‡∏™‡∏π‡∏á‡∏™‡∏∏‡∏î 2 ‡πÉ‡∏ö ‡∏õ‡∏£‡∏∞‡πÄ‡∏†‡∏ó‡∏•‡∏∞ 1 ‡πÉ‡∏ö), ‡∏ó‡∏¥‡πâ‡∏á‡∏Å‡∏≤‡∏£‡πå‡∏î (1 ‡πÉ‡∏ö), ‡∏´‡∏£‡∏∑‡∏≠‡∏Ç‡πâ‡∏≤‡∏°‡πÄ‡∏ó‡∏¥‡∏£‡πå‡∏ô');
  enableButtons(['placeCardsBtn', 'discardBtn', 'skipTurnBtn']);
};

// ‡∏•‡∏á‡∏Å‡∏≤‡∏£‡πå‡∏î
const placeCards = () => {
  console.log('üë§ DEBUG: [HUMAN] placeCards called');
  console.log('üë§ DEBUG: [HUMAN] Current phase:', gameState.phase, 'Turn phase:', gameState.turnPhase);
  console.log('üë§ DEBUG: [HUMAN] Selected cards:', [...gameState.selectedCards]);
  console.log('üë§ DEBUG: [HUMAN] Cards placed this turn:', gameState.cardsPlacedThisTurn);
  console.log('üë§ DEBUG: [HUMAN] Current player:', gameState.currentPlayer);
  
  console.log('üéÆ Debug: placeCards called, phase:', gameState.phase);
  if(gameState.phase === 'pregame') {
    console.log('üë§ DEBUG: [HUMAN] Pregame mode - calling placePregameCard');
    placePregameCard();
    return;
  }
  
  if(gameState.turnPhase !== 'action') {
    console.log('üë§ DEBUG: [HUMAN] Wrong turn phase - expected action, got:', gameState.turnPhase);
    alert('‡∏ï‡πâ‡∏≠‡∏á‡∏à‡∏±‡πà‡∏ß‡∏Å‡∏≤‡∏£‡πå‡∏î‡∏Å‡πà‡∏≠‡∏ô‡∏•‡∏á‡∏Å‡∏≤‡∏£‡πå‡∏î!');
    return;
  }
  
  if(gameState.selectedCards.length === 0) {
    console.log('üë§ DEBUG: [HUMAN] No cards selected');
    alert('‡πÄ‡∏•‡∏∑‡∏≠‡∏Å‡∏Å‡∏≤‡∏£‡πå‡∏î‡∏ó‡∏µ‡πà‡∏ï‡πâ‡∏≠‡∏á‡∏Å‡∏≤‡∏£‡∏•‡∏á‡∏Å‡πà‡∏≠‡∏ô!');
    return;
  }
  
  if(gameState.selectedCards.length > 2) {
    console.log('üë§ DEBUG: [HUMAN] Too many cards selected:', gameState.selectedCards.length);
    alert('‡∏•‡∏á‡πÑ‡∏î‡πâ‡∏™‡∏π‡∏á‡∏™‡∏∏‡∏î 2 ‡πÉ‡∏ö (‡∏õ‡∏£‡∏∞‡πÄ‡∏†‡∏ó‡∏•‡∏∞ 1 ‡πÉ‡∏ö)!');
    return;
  }
  
  // ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡∏õ‡∏£‡∏∞‡πÄ‡∏†‡∏ó‡∏Å‡∏≤‡∏£‡πå‡∏î
  const selectedCardObjs = gameState.selectedCards.map(i => gameState.players[gameState.currentPlayer].hand[i]);
  const setCards = selectedCardObjs.filter(c => c.type === 'set');
  const markerCards = selectedCardObjs.filter(c => c.type === 'marker');
  
  console.log('üë§ DEBUG: [HUMAN] Card type analysis:');
  console.log('üë§ DEBUG: [HUMAN] - Set cards:', setCards.length, setCards.map(c => c.label));
  console.log('üë§ DEBUG: [HUMAN] - Marker cards:', markerCards.length, markerCards.map(c => c.label));
  
  if(setCards.length > 1 || markerCards.length > 1) {
    console.log('üë§ DEBUG: [HUMAN] Multiple cards of same type selected');
    alert('‡∏•‡∏á‡πÑ‡∏î‡πâ‡∏õ‡∏£‡∏∞‡πÄ‡∏†‡∏ó‡∏•‡∏∞ 1 ‡πÉ‡∏ö‡πÄ‡∏ó‡πà‡∏≤‡∏ô‡∏±‡πâ‡∏ô!');
    return;
  }
  
  // ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡∏ß‡πà‡∏≤‡∏•‡∏á‡∏õ‡∏£‡∏∞‡πÄ‡∏†‡∏ó‡∏ô‡∏µ‡πâ‡πÅ‡∏•‡πâ‡∏ß‡∏´‡∏£‡∏∑‡∏≠‡∏¢‡∏±‡∏á
  if(setCards.length > 0 && gameState.cardsPlacedThisTurn.set) {
    console.log('üë§ DEBUG: [HUMAN] Set card already placed this turn');
    alert('‡∏•‡∏á‡∏Å‡∏≤‡∏£‡πå‡∏î‡πÄ‡∏ã‡∏ï‡πÑ‡∏õ‡πÅ‡∏•‡πâ‡∏ß‡πÉ‡∏ô‡πÄ‡∏ó‡∏¥‡∏£‡πå‡∏ô‡∏ô‡∏µ‡πâ!');
    return;
  }
  
  if(markerCards.length > 0 && gameState.cardsPlacedThisTurn.marker) {
    console.log('üë§ DEBUG: [HUMAN] Marker card already placed this turn');
    alert('‡∏•‡∏á‡∏Å‡∏≤‡∏£‡πå‡∏î‡πÄ‡∏Ñ‡∏£‡∏∑‡πà‡∏≠‡∏á‡∏´‡∏°‡∏≤‡∏¢‡πÑ‡∏õ‡πÅ‡∏•‡πâ‡∏ß‡πÉ‡∏ô‡πÄ‡∏ó‡∏¥‡∏£‡πå‡∏ô‡∏ô‡∏µ‡πâ!');
    return;
  }
  
  // ‡∏•‡∏á‡∏Å‡∏≤‡∏£‡πå‡∏î‡πÄ‡∏ã‡∏ï
  if(setCards.length > 0) {
    console.log('üë§ DEBUG: [HUMAN] Processing set card placement');
    const setCard = setCards[0];
    
    // ‡∏à‡∏±‡∏î‡∏Å‡∏≤‡∏£ Empty Set (‡πÄ‡∏ã‡∏ï‡∏ß‡πà‡∏≤‡∏á)
    if(setCard.subtype === 'empty') {
      console.log('üî• Debug: Empty Set detected:', setCard.label);
      if(markerCards.length === 0) {
        alert('Empty Set ‡∏ï‡πâ‡∏≠‡∏á‡πÉ‡∏ä‡πâ‡∏£‡πà‡∏ß‡∏°‡∏Å‡∏±‡∏ö‡∏Å‡∏≤‡∏£‡πå‡∏î‡πÄ‡∏Ñ‡∏£‡∏∑‡πà‡∏≠‡∏á‡∏´‡∏°‡∏≤‡∏¢!');
        return;
      }
      
      const markerCard = markerCards[0];
      console.log('üî• Debug: Using Empty Set with marker:', markerCard.label);
      applyEmptySetWithMarker(setCard, markerCard);
      return; // applyEmptySetWithMarker ‡∏à‡∏±‡∏î‡∏Å‡∏≤‡∏£‡∏•‡∏ö‡∏Å‡∏≤‡∏£‡πå‡∏î‡πÅ‡∏•‡∏∞ update ‡πÄ‡∏≠‡∏á‡πÅ‡∏•‡πâ‡∏ß
    }
    
    // ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡∏Å‡∏≤‡∏£‡∏ó‡∏±‡∏ö‡∏ã‡πâ‡∏≠‡∏ô‡∏ó‡∏±‡πâ‡∏á‡∏´‡∏°‡∏î (‡∏ó‡∏±‡πâ‡∏á‡∏ù‡∏±‡πà‡∏á‡∏ï‡∏£‡∏á‡∏Ç‡πâ‡∏≤‡∏°‡πÅ‡∏•‡∏∞‡∏ï‡∏±‡∏ß‡πÄ‡∏≠‡∏á)
    const conflicts = setCard.cells.filter(pos => gameState.board[pos] && gameState.board[pos] !== gameState.currentPlayer);
    const ownTokens = setCard.cells.filter(pos => gameState.board[pos] === gameState.currentPlayer);
    
    // ‡∏ñ‡πâ‡∏≤‡∏°‡∏µ‡∏Å‡∏≤‡∏£‡πå‡∏î‡πÄ‡∏Ñ‡∏£‡∏∑‡πà‡∏≠‡∏á‡∏´‡∏°‡∏≤‡∏¢ ‡πÅ‡∏™‡∏î‡∏á‡∏ß‡πà‡∏≤‡∏ú‡∏π‡πâ‡πÄ‡∏•‡πà‡∏ô‡∏ï‡πâ‡∏≠‡∏á‡∏Å‡∏≤‡∏£‡πÉ‡∏ä‡πâ operation ‡∏û‡∏¥‡πÄ‡∏®‡∏©
    if(markerCards.length > 0) {
      const markerCard = markerCards[0];
      // Union ‡∏™‡∏≤‡∏°‡∏≤‡∏£‡∏ñ‡∏•‡∏á‡∏ó‡∏±‡∏ö‡πÄ‡∏ö‡∏µ‡πâ‡∏¢‡∏ï‡∏±‡∏ß‡πÄ‡∏≠‡∏á‡πÅ‡∏•‡∏∞‡∏ù‡∏±‡πà‡∏á‡∏ï‡∏£‡∏á‡∏Ç‡πâ‡∏≤‡∏°‡πÑ‡∏î‡πâ
      applySetWithMarker(setCard, markerCard, conflicts);
      return; // applySetWithMarker ‡∏à‡∏±‡∏î‡∏Å‡∏≤‡∏£‡∏•‡∏ö‡∏Å‡∏≤‡∏£‡πå‡∏î‡πÅ‡∏•‡∏∞ update ‡πÄ‡∏≠‡∏á‡πÅ‡∏•‡πâ‡∏ß
    } 
    // ‡∏ñ‡πâ‡∏≤‡∏°‡∏µ‡∏Å‡∏≤‡∏£‡∏ó‡∏±‡∏ö‡∏ã‡πâ‡∏≠‡∏ô‡∏Å‡∏±‡∏ö‡∏ù‡∏±‡πà‡∏á‡∏ï‡∏£‡∏á‡∏Ç‡πâ‡∏≤‡∏° ‡∏ï‡πâ‡∏≠‡∏á‡πÉ‡∏ä‡πâ‡∏Å‡∏≤‡∏£‡πå‡∏î‡πÄ‡∏Ñ‡∏£‡∏∑‡πà‡∏≠‡∏á‡∏´‡∏°‡∏≤‡∏¢‡∏Ñ‡∏ß‡∏ö‡∏Ñ‡∏π‡πà
    else if(conflicts.length > 0) {
      alert(`‡∏Å‡∏≤‡∏£‡πå‡∏î‡πÄ‡∏ã‡∏ï‡∏ó‡∏±‡∏ö‡∏ã‡πâ‡∏≠‡∏ô‡∏Å‡∏±‡∏ö‡πÄ‡∏ö‡∏µ‡πâ‡∏¢‡∏ù‡∏±‡πà‡∏á‡∏ï‡∏£‡∏á‡∏Ç‡πâ‡∏≤‡∏°‡∏ó‡∏µ‡πà: ${conflicts.join(', ')}\n‡∏ï‡πâ‡∏≠‡∏á‡πÄ‡∏•‡∏∑‡∏≠‡∏Å‡∏Å‡∏≤‡∏£‡πå‡∏î‡πÄ‡∏Ñ‡∏£‡∏∑‡πà‡∏≠‡∏á‡∏´‡∏°‡∏≤‡∏¢‡∏Ñ‡∏ß‡∏ö‡∏Ñ‡∏π‡πà‡πÄ‡∏û‡∏∑‡πà‡∏≠‡πÉ‡∏ä‡πâ‡∏á‡∏≤‡∏ô!`);
      return;
    }
    // ‡∏ñ‡πâ‡∏≤‡∏ó‡∏±‡∏ö‡∏ã‡πâ‡∏≠‡∏ô‡∏Å‡∏±‡∏ö‡πÄ‡∏ö‡∏µ‡πâ‡∏¢‡∏ï‡∏±‡∏ß‡πÄ‡∏≠‡∏á ‡πÅ‡∏à‡πâ‡∏á‡πÄ‡∏ï‡∏∑‡∏≠‡∏ô
    else if(ownTokens.length > 0) {
      alert(`‡∏Å‡∏≤‡∏£‡πå‡∏î‡πÄ‡∏ã‡∏ï‡∏ó‡∏±‡∏ö‡∏ã‡πâ‡∏≠‡∏ô‡∏Å‡∏±‡∏ö‡πÄ‡∏ö‡∏µ‡πâ‡∏¢‡∏Ç‡∏≠‡∏á‡∏ï‡∏±‡∏ß‡πÄ‡∏≠‡∏á‡∏ó‡∏µ‡πà: ${ownTokens.join(', ')}\n‡πÑ‡∏°‡πà‡∏™‡∏≤‡∏°‡∏≤‡∏£‡∏ñ‡∏•‡∏á‡∏ó‡∏±‡∏ö‡πÑ‡∏î‡πâ!`);
      return;
    }
    else {
      // ‡∏•‡∏á‡∏Å‡∏≤‡∏£‡πå‡∏î‡πÄ‡∏ã‡∏ï‡∏õ‡∏Å‡∏ï‡∏¥ (‡πÑ‡∏°‡πà‡∏°‡∏µ‡∏Å‡∏≤‡∏£‡∏ó‡∏±‡∏ö‡∏ã‡πâ‡∏≠‡∏ô)
      try {
        placeTokens(setCard.cells, gameState.currentPlayer);
        gameState.cardsPlacedThisTurn.set = true;
        
        const playerName = gameState.currentPlayer === 'black' ? '‡∏ú‡∏π‡πâ‡πÄ‡∏•‡πà‡∏ô‡∏î‡∏≥' : '‡∏ú‡∏π‡πâ‡πÄ‡∏•‡πà‡∏ô‡∏Ç‡∏≤‡∏ß';
        logMessage(`${playerName} ‡∏•‡∏á‡∏Å‡∏≤‡∏£‡πå‡∏î‡πÄ‡∏ã‡∏ï: ${setCard.label}`);
      } catch (error) {
        console.error('Error placing set card:', error);
        alert('‡πÄ‡∏Å‡∏¥‡∏î‡∏Ç‡πâ‡∏≠‡∏ú‡∏¥‡∏î‡∏û‡∏•‡∏≤‡∏î‡πÉ‡∏ô‡∏Å‡∏≤‡∏£‡∏•‡∏á‡∏Å‡∏≤‡∏£‡πå‡∏î‡πÄ‡∏ã‡∏ï: ' + error.message);
        return;
      }
    }
  }
  
  // ‡∏•‡∏á‡∏Å‡∏≤‡∏£‡πå‡∏î‡πÄ‡∏Ñ‡∏£‡∏∑‡πà‡∏≠‡∏á‡∏´‡∏°‡∏≤‡∏¢‡πÇ‡∏î‡∏¢‡∏•‡∏≥‡∏û‡∏±‡∏á (‡∏ï‡πâ‡∏≠‡∏á‡∏°‡∏µ‡∏Å‡∏≤‡∏£‡πå‡∏î‡πÄ‡∏ã‡∏ï 2 ‡πÉ‡∏ö)
  if(markerCards.length > 0 && setCards.length === 0) {
    const markerCard = markerCards[0];
    
    // ‡πÉ‡∏ô‡πÄ‡∏Å‡∏°‡∏ô‡∏µ‡πâ‡πÑ‡∏°‡πà‡∏™‡∏≤‡∏°‡∏≤‡∏£‡∏ñ‡πÉ‡∏ä‡πâ‡∏Å‡∏≤‡∏£‡πå‡∏î‡πÄ‡∏Ñ‡∏£‡∏∑‡πà‡∏≠‡∏á‡∏´‡∏°‡∏≤‡∏¢‡∏Å‡∏±‡∏ö‡∏Å‡∏≤‡∏£‡πå‡∏î‡πÄ‡∏ã‡∏ï 2 ‡πÉ‡∏ö‡πÑ‡∏î‡πâ
    alert('‡πÉ‡∏ô‡πÄ‡∏Å‡∏°‡∏ô‡∏µ‡πâ‡πÉ‡∏ä‡πâ‡∏Å‡∏≤‡∏£‡πå‡∏î‡πÄ‡∏Ñ‡∏£‡∏∑‡πà‡∏≠‡∏á‡∏´‡∏°‡∏≤‡∏¢‡∏Å‡∏±‡∏ö‡∏Å‡∏≤‡∏£‡πå‡∏î‡πÄ‡∏ã‡∏ï 1 ‡πÉ‡∏ö‡πÄ‡∏ó‡πà‡∏≤‡∏ô‡∏±‡πâ‡∏ô!');
    return;
  }
  
  // ‡∏•‡∏ö‡∏Å‡∏≤‡∏£‡πå‡∏î‡∏ó‡∏µ‡πà‡∏•‡∏á‡πÅ‡∏•‡πâ‡∏ß‡∏≠‡∏≠‡∏Å‡∏à‡∏≤‡∏Å‡∏°‡∏∑‡∏≠
  console.log('üî• DEBUG: [Normal] About to remove cards from hand');
  console.log('üî• DEBUG: [Normal] Current hand size:', gameState.players[gameState.currentPlayer].hand.length);
  console.log('üî• DEBUG: [Normal] Selected cards:', gameState.selectedCards);
  
  gameState.selectedCards.sort((a, b) => b - a).forEach(index => {
    const card = gameState.players[gameState.currentPlayer].hand[index];
    if (card) {
      console.log('üî• DEBUG: [Normal] Removing card:', card.label, 'at index', index);
      gameState.players[gameState.currentPlayer].hand.splice(index, 1);
    } else {
      console.error('üî• DEBUG: [Normal] No card found at index', index);
    }
  });
  
  console.log('üî• DEBUG: [Normal] Hand size after removal:', gameState.players[gameState.currentPlayer].hand.length);
  
  gameState.selectedCards = [];
  updateDisplay();
  
  // ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡∏ß‡πà‡∏≤‡∏™‡∏≤‡∏°‡∏≤‡∏£‡∏ñ‡∏•‡∏á‡∏Å‡∏≤‡∏£‡πå‡∏î‡πÄ‡∏û‡∏¥‡πà‡∏°‡πÑ‡∏î‡πâ‡∏´‡∏£‡∏∑‡∏≠‡πÑ‡∏°‡πà
  const canPlaceMore = (!gameState.cardsPlacedThisTurn.set || !gameState.cardsPlacedThisTurn.marker) &&
                      gameState.players[gameState.currentPlayer].hand.length > 0;
  
  if(canPlaceMore) {
    updateGameStatus('‡∏™‡∏≤‡∏°‡∏≤‡∏£‡∏ñ‡∏•‡∏á‡∏Å‡∏≤‡∏£‡πå‡∏î‡πÄ‡∏û‡∏¥‡πà‡∏°‡πÑ‡∏î‡πâ (‡∏õ‡∏£‡∏∞‡πÄ‡∏†‡∏ó‡∏•‡∏∞ 1 ‡πÉ‡∏ö) ‡∏´‡∏£‡∏∑‡∏≠‡πÄ‡∏•‡∏∑‡∏≠‡∏Å‡∏ó‡∏¥‡πâ‡∏á‡∏Å‡∏≤‡∏£‡πå‡∏î/‡∏Ç‡πâ‡∏≤‡∏°‡πÄ‡∏ó‡∏¥‡∏£‡πå‡∏ô');
    enableButtons(['placeCardsBtn', 'discardBtn', 'skipTurnBtn']);
  } else {
    // ‡∏à‡∏ö‡πÄ‡∏ó‡∏¥‡∏£‡πå‡∏ô‡πÄ‡∏°‡∏∑‡πà‡∏≠‡∏•‡∏á‡∏Å‡∏≤‡∏£‡πå‡∏î‡∏Ñ‡∏£‡∏ö‡πÅ‡∏•‡πâ‡∏ß
    // ‡∏ú‡∏π‡πâ‡πÄ‡∏•‡πà‡∏ô‡∏ï‡πâ‡∏≠‡∏á‡∏Å‡∏î‡∏à‡∏ö‡πÄ‡∏ó‡∏¥‡∏£‡πå‡∏ô‡πÄ‡∏≠‡∏á
    updateGameStatus('‡∏•‡∏á‡∏Å‡∏≤‡∏£‡πå‡∏î‡∏Ñ‡∏£‡∏ö‡πÅ‡∏•‡πâ‡∏ß - ‡∏Å‡∏î‡∏Ç‡πâ‡∏≤‡∏°/‡∏à‡∏ö‡πÄ‡∏ó‡∏¥‡∏£‡πå‡∏ô ‡πÄ‡∏û‡∏∑‡πà‡∏≠‡∏à‡∏ö‡πÄ‡∏ó‡∏¥‡∏£‡πå‡∏ô');
    enableButtons(['skipTurnBtn']);
  }
};

// ‡∏ß‡∏≤‡∏á‡∏Å‡∏≤‡∏£‡πå‡∏î‡∏Å‡πà‡∏≠‡∏ô‡πÄ‡∏£‡∏¥‡πà‡∏°‡πÄ‡∏Å‡∏°
const placePregameCard = () => {
  console.log('üéÆ Debug: placePregameCard called');
  if(gameState.selectedCards.length !== 1) {
    alert('‡πÄ‡∏•‡∏∑‡∏≠‡∏Å‡∏Å‡∏≤‡∏£‡πå‡∏î‡πÄ‡∏ã‡∏ï 1 ‡πÉ‡∏ö!');
    return;
  }
  
  const cardIndex = gameState.selectedCards[0];
  const card = gameState.players[gameState.currentPlayer].hand[cardIndex];
  console.log('üéÆ Debug: Current player:', gameState.currentPlayer, 'Card:', card.label);
  
  if(card.type !== 'set') {
    alert('‡∏ï‡πâ‡∏≠‡∏á‡πÄ‡∏•‡∏∑‡∏≠‡∏Å‡∏Å‡∏≤‡∏£‡πå‡∏î‡πÄ‡∏ã‡∏ï‡πÄ‡∏ó‡πà‡∏≤‡∏ô‡∏±‡πâ‡∏ô!');
    return;
  }
  
  // ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡∏Å‡∏≤‡∏£‡∏ó‡∏±‡∏ö‡∏ã‡πâ‡∏≠‡∏ô (‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡∏ú‡∏π‡πâ‡πÄ‡∏•‡πà‡∏ô‡∏Ñ‡∏ô‡∏ó‡∏µ‡πà‡∏™‡∏≠‡∏á)
  if(gameState.currentPlayer === 'white') {
    const conflicts = card.cells.filter(pos => gameState.board[pos]);
    console.log('üéÆ Debug: Checking conflicts for white player:', conflicts);
    if(conflicts.length > 0) {
      console.log('üéÆ Debug: Conflicts found, showing dialog');
      // ‡πÄ‡∏™‡∏ô‡∏≠‡πÉ‡∏´‡πâ‡πÄ‡∏õ‡∏•‡∏µ‡πà‡∏¢‡∏ô‡∏Å‡∏≤‡∏£‡πå‡∏î
      const changeCard = confirm(`‡∏Å‡∏≤‡∏£‡πå‡∏î‡∏ó‡∏±‡∏ö‡∏ã‡πâ‡∏≠‡∏ô‡∏Å‡∏±‡∏ö‡∏ú‡∏π‡πâ‡πÄ‡∏•‡πà‡∏ô‡πÅ‡∏£‡∏Å‡∏ó‡∏µ‡πà: ${conflicts.join(', ')}\n\n‡∏ï‡πâ‡∏≠‡∏á‡∏Å‡∏≤‡∏£‡πÄ‡∏õ‡∏•‡∏µ‡πà‡∏¢‡∏ô‡∏Å‡∏≤‡∏£‡πå‡∏î‡πÉ‡∏´‡∏°‡πà‡∏´‡∏£‡∏∑‡∏≠‡πÑ‡∏°‡πà?\n(OK = ‡πÄ‡∏õ‡∏•‡∏µ‡πà‡∏¢‡∏ô‡∏Å‡∏≤‡∏£‡πå‡∏î, Cancel = ‡πÄ‡∏•‡∏∑‡∏≠‡∏Å‡∏Å‡∏≤‡∏£‡πå‡∏î‡∏≠‡∏∑‡πà‡∏ô‡∏à‡∏≤‡∏Å‡∏°‡∏∑‡∏≠)`);
      
      if(changeCard) {
        console.log('üéÆ Debug: User chose to change card from deck');
        // ‡πÄ‡∏õ‡∏•‡∏µ‡πà‡∏¢‡∏ô‡∏Å‡∏≤‡∏£‡πå‡∏î‡πÉ‡∏´‡∏°‡πà‡∏à‡∏≤‡∏Å‡∏Å‡∏≠‡∏á
        changeCardFromDeck();
        return;
      } else {
        console.log('üéÆ Debug: User chose to select different card from hand');
        // ‡πÉ‡∏´‡πâ‡πÄ‡∏•‡∏∑‡∏≠‡∏Å‡∏Å‡∏≤‡∏£‡πå‡∏î‡∏≠‡∏∑‡πà‡∏ô‡∏à‡∏≤‡∏Å‡∏°‡∏∑‡∏≠
        gameState.selectedCards = [];
        updateDisplay();
        return;
      }
    }
  }
  
  placeTokens(card.cells, gameState.currentPlayer);
  gameState.players[gameState.currentPlayer].hand.splice(cardIndex, 1);
  gameState.selectedCards = [];
  
  const playerName = gameState.currentPlayer === 'black' ? '‡∏ú‡∏π‡πâ‡πÄ‡∏•‡πà‡∏ô‡∏î‡∏≥' : '‡∏ú‡∏π‡πâ‡πÄ‡∏•‡πà‡∏ô‡∏Ç‡∏≤‡∏ß';
  logMessage(`${playerName} ‡∏ß‡∏≤‡∏á‡∏Å‡∏≤‡∏£‡πå‡∏î‡πÄ‡∏ã‡∏ï‡πÄ‡∏£‡∏¥‡πà‡∏°‡∏ï‡πâ‡∏ô: ${card.label}`);
  
  if(gameState.currentPlayer === 'black') {
    gameState.currentPlayer = 'white';
    updateDisplay();
    
    updateGameStatus('‡∏ú‡∏π‡πâ‡πÄ‡∏•‡πà‡∏ô‡∏Ç‡∏≤‡∏ß: ‡πÄ‡∏•‡∏∑‡∏≠‡∏Å‡∏Å‡∏≤‡∏£‡πå‡∏î‡πÄ‡∏ã‡∏ï 1 ‡πÉ‡∏ö‡πÄ‡∏û‡∏∑‡πà‡∏≠‡∏ß‡∏≤‡∏á‡πÄ‡∏ö‡∏µ‡πâ‡∏¢‡πÄ‡∏£‡∏¥‡πà‡∏°‡∏ï‡πâ‡∏ô (‡∏ï‡πâ‡∏≠‡∏á‡πÑ‡∏°‡πà‡∏ó‡∏±‡∏ö‡∏Å‡∏±‡∏ö‡∏ú‡∏π‡πâ‡πÄ‡∏•‡πà‡∏ô‡∏î‡∏≥)');
    enableButtons(['placeCardsBtn']);
  } else {
    // ‡πÄ‡∏£‡∏¥‡πà‡∏°‡πÄ‡∏Å‡∏°‡∏à‡∏£‡∏¥‡∏á
    gameState.phase = 'playing';
    gameState.turn = 1;
    gameState.turnPhase = 'draw';
    gameState.currentPlayer = 'black';
    gameState.drawnThisTurn = false;
    gameState.cardsPlacedThisTurn = { set: false, marker: false };
    
    logMessage('üéØ ‡πÄ‡∏£‡∏¥‡πà‡∏°‡πÄ‡∏Å‡∏°‡∏à‡∏£‡∏¥‡∏á! ‡πÄ‡∏ó‡∏¥‡∏£‡πå‡∏ô‡∏ó‡∏µ‡πà 1 - ‡∏ú‡∏π‡πâ‡πÄ‡∏•‡πà‡∏ô‡∏î‡∏≥');
    updateDisplay();
    
    updateGameStatus('‡∏ú‡∏π‡πâ‡πÄ‡∏•‡πà‡∏ô‡∏î‡∏≥: ‡∏à‡∏±‡πà‡∏ß‡∏Å‡∏≤‡∏£‡πå‡∏î 1 ‡πÉ‡∏ö‡∏Å‡πà‡∏≠‡∏ô');
    enableButtons(['drawSetBtn', 'drawMarkerBtn']);
  }
};

// ‡πÅ‡∏™‡∏î‡∏á Modal ‡πÄ‡∏•‡∏∑‡∏≠‡∏Å‡∏Å‡∏≤‡∏£‡πå‡∏î‡πÄ‡∏ã‡∏ï
// ‡πÉ‡∏ä‡πâ‡∏Å‡∏≤‡∏£‡πå‡∏î‡πÄ‡∏ã‡∏ï‡∏Å‡∏±‡∏ö‡πÄ‡∏Ñ‡∏£‡∏∑‡πà‡∏≠‡∏á‡∏´‡∏°‡∏≤‡∏¢‡∏Ñ‡∏ß‡∏ö‡∏Ñ‡∏π‡πà (‡πÄ‡∏°‡∏∑‡πà‡∏≠‡∏°‡∏µ‡∏Å‡∏≤‡∏£‡∏ó‡∏±‡∏ö‡∏ã‡πâ‡∏≠‡∏ô)
const applySetWithMarker = (setCard, markerCard, conflicts) => {
  let resultCells = [];
  const opponentColor = gameState.currentPlayer === 'black' ? 'white' : 'black';
  
  console.log(`Applying ${markerCard.subtype} with set:`, setCard.cells, 'conflicts:', conflicts);
  
  switch(markerCard.subtype) {
    case 'union':
      // ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡∏Å‡∏≤‡∏£‡πå‡∏î‡πÄ‡∏ã‡∏ï‡∏ß‡πà‡∏≤‡∏á (‡πÑ‡∏°‡πà‡∏°‡∏µ cells ‡∏´‡∏£‡∏∑‡∏≠ cells ‡πÄ‡∏õ‡πá‡∏ô array ‡∏ß‡πà‡∏≤‡∏á)
      if (!setCard.cells || setCard.cells.length === 0) {
        // 2.1.1 ‡πÄ‡∏ã‡∏ï‡πÉ‡∏î ‡πÜ ‡∏¢‡∏π‡πÄ‡∏ô‡∏µ‡∏¢‡∏ô‡∏Å‡∏±‡∏ö‡πÄ‡∏ã‡∏ï‡∏ß‡πà‡∏≤‡∏á: ‡πÑ‡∏°‡πà‡πÄ‡∏Å‡∏¥‡∏î‡∏ú‡∏•‡πÉ‡∏î ‡πÜ ‡∏Å‡∏±‡∏ö‡∏™‡∏°‡∏≤‡∏ä‡∏¥‡∏Å‡∏ó‡∏µ‡πà‡∏≠‡∏¢‡∏π‡πà‡∏ö‡∏ô‡∏Å‡∏£‡∏∞‡∏î‡∏≤‡∏ô
        console.log('Union with empty set: No effect on board');
        resultCells = [];
      } else {
        // Union: ‡∏¢‡∏∂‡∏î‡∏Ñ‡∏£‡∏≠‡∏á‡∏û‡∏∑‡πâ‡∏ô‡∏ó‡∏µ‡πà‡∏ó‡∏±‡πâ‡∏á‡∏´‡∏°‡∏î‡∏Ç‡∏≠‡∏á‡∏Å‡∏≤‡∏£‡πå‡∏î‡πÄ‡∏ã‡∏ï + ‡∏û‡∏∑‡πâ‡∏ô‡∏ó‡∏µ‡πà‡∏ó‡∏µ‡πà‡πÄ‡∏ä‡∏∑‡πà‡∏≠‡∏°‡∏ï‡πà‡∏≠‡∏Å‡∏±‡∏ô‡∏Ç‡∏≠‡∏á‡∏ù‡∏±‡πà‡∏á‡∏ï‡∏£‡∏á‡∏Ç‡πâ‡∏≤‡∏°
        resultCells = [...setCard.cells];
        console.log('Union: Starting with set cells:', resultCells);
        
        // ‡∏´‡∏≤‡∏û‡∏∑‡πâ‡∏ô‡∏ó‡∏µ‡πà‡∏ó‡∏µ‡πà‡πÄ‡∏ä‡∏∑‡πà‡∏≠‡∏°‡∏ï‡πà‡∏≠‡∏Å‡∏±‡∏ô‡∏Ç‡∏≠‡∏á‡∏ù‡∏±‡πà‡∏á‡∏ï‡∏£‡∏á‡∏Ç‡πâ‡∏≤‡∏°‡∏ó‡∏µ‡πà‡∏ï‡∏¥‡∏î‡∏Å‡∏±‡∏ö‡∏û‡∏∑‡πâ‡∏ô‡∏ó‡∏µ‡πà‡πÉ‡∏´‡∏°‡πà
        // ‡∏´‡∏≤‡∏û‡∏∑‡πâ‡∏ô‡∏ó‡∏µ‡πà‡∏ó‡∏µ‡πà‡πÄ‡∏ä‡∏∑‡πà‡∏≠‡∏°‡∏ï‡πà‡∏≠‡∏Å‡∏±‡∏ô‡∏Ç‡∏≠‡∏á‡∏ù‡∏±‡πà‡∏á‡∏ï‡∏£‡∏á‡∏Ç‡πâ‡∏≤‡∏°‡∏ó‡∏µ‡πà‡∏ï‡∏¥‡∏î‡∏Å‡∏±‡∏ö‡∏û‡∏∑‡πâ‡∏ô‡∏ó‡∏µ‡πà‡πÉ‡∏´‡∏°‡πà
        const adjacentOpponentTokens = new Set();
        setCard.cells.forEach(pos => {
          const adjacent = getAdjacentCells(pos);
          adjacent.forEach(adjPos => {
            if (gameState.board[adjPos] === opponentColor) {
              adjacentOpponentTokens.add(adjPos);
            }
          });
        });
        console.log('Union: Adjacent opponent tokens:', Array.from(adjacentOpponentTokens));
        
        // ‡∏´‡∏≤‡∏û‡∏∑‡πâ‡∏ô‡∏ó‡∏µ‡πà‡∏ó‡∏µ‡πà‡πÄ‡∏ä‡∏∑‡πà‡∏≠‡∏°‡∏ï‡πà‡∏≠‡∏Å‡∏±‡∏ô‡∏ó‡∏±‡πâ‡∏á‡∏´‡∏°‡∏î‡∏Ç‡∏≠‡∏á‡∏ù‡∏±‡πà‡∏á‡∏ï‡∏£‡∏á‡∏Ç‡πâ‡∏≤‡∏°
        if (adjacentOpponentTokens.size > 0) {
          const connectedOpponentArea = getConnectedArea(Array.from(adjacentOpponentTokens), opponentColor);
          console.log('Union: Connected opponent area:', connectedOpponentArea);
          resultCells = [...resultCells, ...connectedOpponentArea];
        }
        
        // ‡∏•‡∏ö‡∏Ñ‡πà‡∏≤‡∏ã‡πâ‡∏≥
        resultCells = [...new Set(resultCells)];
        console.log('Union: Final result cells:', resultCells);
        
        if (resultCells.length === 0) {
          console.error('Union resulted in 0 cells!');
          throw new Error('‡∏Å‡∏≤‡∏£‡∏î‡∏≥‡πÄ‡∏ô‡∏¥‡∏ô‡∏Å‡∏≤‡∏£ Union ‡πÑ‡∏°‡πà‡πÑ‡∏î‡πâ‡∏ú‡∏•‡∏•‡∏±‡∏û‡∏ò‡πå');
        }
      }
      break;
      
    case 'intersection':
      // Intersection + Empty Set: ‡∏•‡∏ö‡πÄ‡∏â‡∏û‡∏≤‡∏∞‡πÄ‡∏ö‡∏µ‡πâ‡∏¢‡∏ù‡πà‡∏≤‡∏¢‡∏ï‡∏£‡∏á‡∏Ç‡πâ‡∏≤‡∏°‡∏ó‡∏±‡πâ‡∏á‡∏Å‡∏£‡∏∞‡∏î‡∏≤‡∏ô
      if (!setCard.cells || setCard.cells.length === 0) {
        const opponentColor = gameState.currentPlayer === 'black' ? 'white' : 'black';
        let removed = 0;
        for (let row = 0; row < 8; row++) {
          for (let col = 0; col < 8; col++) {
            const pos = `${String.fromCharCode(65 + row)}${col + 1}`;
            if (gameState.board[pos] === opponentColor) {
              delete gameState.board[pos];
              removed++;
              const cell = document.querySelector(`[data-position="${pos}"]`);
              if(cell) {
                cell.innerHTML = pos;
                cell.style.backgroundColor = 'white';
              }
            }
          }
        }
        updateTokenCounts();
        showToast(`‡∏•‡∏ö‡πÄ‡∏ö‡∏µ‡πâ‡∏¢‡∏ù‡πà‡∏≤‡∏¢‡∏ï‡∏£‡∏á‡∏Ç‡πâ‡∏≤‡∏°‡∏ó‡∏±‡πâ‡∏á‡∏Å‡∏£‡∏∞‡∏î‡∏≤‡∏ô ${removed} ‡∏ä‡πà‡∏≠‡∏á (Empty Set + Intersection)`, 'success');
        resultCells = [];
        // ‡∏•‡∏ö‡∏Å‡∏≤‡∏£‡πå‡∏î‡∏ó‡∏µ‡πà‡πÉ‡∏ä‡πâ‡∏ó‡∏±‡πâ‡∏á‡∏™‡∏≠‡∏á‡πÉ‡∏ö
        const setIndex = gameState.selectedCards.find(i => gameState.players[gameState.currentPlayer].hand[i].type === 'set');
        const markerIndex = gameState.selectedCards.find(i => gameState.players[gameState.currentPlayer].hand[i].type === 'marker');
        const allIndices = [setIndex, markerIndex].sort((a, b) => b - a);
        allIndices.forEach(index => gameState.players[gameState.currentPlayer].hand.splice(index, 1));
        gameState.selectedCards = [];
        gameState.cardsPlacedThisTurn.set = true;
        gameState.cardsPlacedThisTurn.marker = true;
        updateDisplay();
        updateGameStatus('‡∏Å‡∏î‡∏Ç‡πâ‡∏≤‡∏°‡πÄ‡∏ó‡∏¥‡∏£‡πå‡∏ô‡πÄ‡∏û‡∏∑‡πà‡∏≠‡∏à‡∏ö‡πÄ‡∏ó‡∏¥‡∏£‡πå‡∏ô');
        enableButtons(['skipTurnBtn']);
        return;
      } else {
        // Intersection: ‡πÑ‡∏î‡πâ‡πÄ‡∏â‡∏û‡∏≤‡∏∞‡∏û‡∏∑‡πâ‡∏ô‡∏ó‡∏µ‡πà‡∏ó‡∏µ‡πà‡∏°‡∏µ‡πÄ‡∏ö‡∏µ‡πâ‡∏¢‡∏≠‡∏¢‡∏π‡πà‡πÅ‡∏•‡πâ‡∏ß (‡∏ó‡∏±‡πâ‡∏á‡∏™‡∏≠‡∏á‡∏ù‡πà‡∏≤‡∏¢)
        const existingTokensInSet = setCard.cells.filter(pos => gameState.board[pos]);
        if (existingTokensInSet.length === 0) {
          showToast('‡πÑ‡∏°‡πà‡∏°‡∏µ‡πÄ‡∏ö‡∏µ‡πâ‡∏¢‡πÉ‡∏ô‡∏û‡∏∑‡πâ‡∏ô‡∏ó‡∏µ‡πà‡πÄ‡∏ã‡∏ï‡∏ô‡∏µ‡πâ‡∏ó‡∏µ‡πà‡∏à‡∏∞‡∏ó‡∏≥ Intersection ‡πÑ‡∏î‡πâ!', 'warning');
          // ‡∏•‡∏ö‡∏Å‡∏≤‡∏£‡πå‡∏î‡∏ó‡∏µ‡πà‡πÉ‡∏ä‡πâ‡∏ó‡∏±‡πâ‡∏á‡∏™‡∏≠‡∏á‡πÉ‡∏ö‡πÅ‡∏°‡πâ‡πÑ‡∏°‡πà‡∏™‡∏≥‡πÄ‡∏£‡πá‡∏à
          const setIndex = gameState.selectedCards.find(i => gameState.players[gameState.currentPlayer].hand[i].type === 'set');
          const markerIndex = gameState.selectedCards.find(i => gameState.players[gameState.currentPlayer].hand[i].type === 'marker');
          const allIndices = [setIndex, markerIndex].sort((a, b) => b - a);
          allIndices.forEach(index => gameState.players[gameState.currentPlayer].hand.splice(index, 1));
          gameState.selectedCards = [];
          updateDisplay();
          return;
        }
        resultCells = existingTokensInSet;
        console.log(`Intersection: ‡πÑ‡∏î‡πâ‡∏û‡∏∑‡πâ‡∏ô‡∏ó‡∏µ‡πà‡∏ó‡∏µ‡πà‡∏°‡∏µ‡πÄ‡∏ö‡∏µ‡πâ‡∏¢‡∏≠‡∏¢‡∏π‡πà‡πÅ‡∏•‡πâ‡∏ß ${resultCells.length} ‡∏ä‡πà‡∏≠‡∏á: ${resultCells.join(', ')}`);
      }
      break;
      
    case 'difference':
      // ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡∏Å‡∏≤‡∏£‡πå‡∏î‡πÄ‡∏ã‡∏ï‡∏ß‡πà‡∏≤‡∏á (‡πÑ‡∏°‡πà‡∏°‡∏µ cells ‡∏´‡∏£‡∏∑‡∏≠ cells ‡πÄ‡∏õ‡πá‡∏ô array ‡∏ß‡πà‡∏≤‡∏á)
      if (!setCard.cells || setCard.cells.length === 0) {
        // 2.1.3 ‡πÄ‡∏ã‡∏ï‡πÉ‡∏î ‡πÜ ‡∏ú‡∏•‡∏ï‡πà‡∏≤‡∏á‡∏Å‡∏±‡∏ö‡πÄ‡∏ã‡∏ï‡∏ß‡πà‡∏≤‡∏á: ‡πÑ‡∏°‡πà‡πÄ‡∏Å‡∏¥‡∏î‡∏ú‡∏•‡πÉ‡∏î ‡πÜ ‡∏Å‡∏±‡∏ö‡∏™‡∏°‡∏≤‡∏ä‡∏¥‡∏Å‡∏ó‡∏µ‡πà‡∏≠‡∏¢‡∏π‡πà‡∏ö‡∏ô‡∏Å‡∏£‡∏∞‡∏î‡∏≤‡∏ô
        console.log('Difference with empty set: No effect on board');
        resultCells = [];
      } else {
        // Difference: ‡∏•‡∏ö‡πÄ‡∏ö‡∏µ‡πâ‡∏¢‡∏ó‡∏±‡πâ‡∏á‡∏´‡∏°‡∏î‡πÉ‡∏ô‡∏û‡∏∑‡πâ‡∏ô‡∏ó‡∏µ‡πà‡∏Å‡∏≤‡∏£‡πå‡∏î‡πÄ‡∏ã‡∏ï‡∏≠‡∏≠‡∏Å‡∏à‡∏≤‡∏Å‡∏Å‡∏£‡∏∞‡∏î‡∏≤‡∏ô (‡πÑ‡∏°‡πà‡∏ß‡πà‡∏≤‡∏à‡∏∞‡πÄ‡∏õ‡πá‡∏ô‡∏Ç‡∏≠‡∏á‡πÉ‡∏Ñ‡∏£)
        // ‡πÑ‡∏°‡πà‡πÑ‡∏î‡πâ‡∏û‡∏∑‡πâ‡∏ô‡∏ó‡∏µ‡πà‡πÄ‡∏û‡∏¥‡πà‡∏° ‡πÅ‡∏Ñ‡πà‡∏•‡∏ö‡πÄ‡∏ö‡∏µ‡πâ‡∏¢‡∏≠‡∏≠‡∏Å
        const tokensInSetArea = setCard.cells.filter(pos => 
          gameState.board[pos] // ‡∏°‡∏µ‡πÄ‡∏ö‡∏µ‡πâ‡∏¢‡∏≠‡∏¢‡∏π‡πà‡πÉ‡∏ô‡∏ï‡∏≥‡πÅ‡∏´‡∏ô‡πà‡∏á‡∏ô‡∏µ‡πâ
        );
        
        if (tokensInSetArea.length === 0) {
          showToast('‡πÑ‡∏°‡πà‡∏°‡∏µ‡πÄ‡∏ö‡∏µ‡πâ‡∏¢‡πÉ‡∏ô‡∏û‡∏∑‡πâ‡∏ô‡∏ó‡∏µ‡πà‡πÄ‡∏ã‡∏ï‡∏ô‡∏µ‡πâ‡∏ó‡∏µ‡πà‡∏à‡∏∞‡∏•‡∏ö‡πÑ‡∏î‡πâ!', 'warning');
          
          // ‡∏•‡∏ö‡∏Å‡∏≤‡∏£‡πå‡∏î‡∏ó‡∏µ‡πà‡πÉ‡∏ä‡πâ‡∏ó‡∏±‡πâ‡∏á‡∏™‡∏≠‡∏á‡πÉ‡∏ö‡πÅ‡∏°‡πâ‡πÑ‡∏°‡πà‡∏™‡∏≥‡πÄ‡∏£‡πá‡∏à
          const setIndex = gameState.selectedCards.find(i => gameState.players[gameState.currentPlayer].hand[i].type === 'set');
          const markerIndex = gameState.selectedCards.find(i => gameState.players[gameState.currentPlayer].hand[i].type === 'marker');
          const allIndices = [setIndex, markerIndex].sort((a, b) => b - a);
          allIndices.forEach(index => gameState.players[gameState.currentPlayer].hand.splice(index, 1));
          
          gameState.selectedCards = [];
          updateDisplay();
          return;
        }
        
        // ‡∏•‡∏ö‡πÄ‡∏ö‡∏µ‡πâ‡∏¢‡∏ó‡∏±‡πâ‡∏á‡∏´‡∏°‡∏î‡πÉ‡∏ô‡∏û‡∏∑‡πâ‡∏ô‡∏ó‡∏µ‡πà‡∏Å‡∏≤‡∏£‡πå‡∏î‡πÄ‡∏ã‡∏ï (‡πÑ‡∏°‡πà‡∏ß‡πà‡∏≤‡∏à‡∏∞‡πÄ‡∏õ‡πá‡∏ô‡∏Ç‡∏≠‡∏á‡πÉ‡∏Ñ‡∏£)
        tokensInSetArea.forEach(pos => {
          delete gameState.board[pos];
          const cell = document.querySelector(`[data-position="${pos}"]`);
          if(cell) {
            cell.innerHTML = pos;
            cell.style.backgroundColor = 'white';
          }
        });
        
        // ‡∏≠‡∏±‡∏û‡πÄ‡∏î‡∏ó‡∏à‡∏≥‡∏ô‡∏ß‡∏ô‡πÄ‡∏ö‡∏µ‡πâ‡∏¢‡∏´‡∏•‡∏±‡∏á‡∏•‡∏ö
        updateTokenCounts();
        
        // ‡πÑ‡∏°‡πà‡πÑ‡∏î‡πâ‡∏û‡∏∑‡πâ‡∏ô‡∏ó‡∏µ‡πà‡πÄ‡∏û‡∏¥‡πà‡∏° - ‡πÅ‡∏Ñ‡πà‡∏•‡∏ö‡πÄ‡∏ö‡∏µ‡πâ‡∏¢‡∏ó‡∏±‡πâ‡∏á‡∏´‡∏°‡∏î‡πÉ‡∏ô‡πÄ‡∏ã‡∏ï
        resultCells = [];
        
        console.log(`Difference: ‡∏•‡∏ö‡πÄ‡∏ö‡∏µ‡πâ‡∏¢‡∏ó‡∏±‡πâ‡∏á‡∏´‡∏°‡∏î ${tokensInSetArea.length} ‡∏ä‡πà‡∏≠‡∏á: ${tokensInSetArea.join(', ')}`);
      }
      break;
      
    case 'complement':
      // ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡∏Å‡∏≤‡∏£‡πå‡∏î‡πÄ‡∏ã‡∏ï‡∏ß‡πà‡∏≤‡∏á (‡πÑ‡∏°‡πà‡∏°‡∏µ cells ‡∏´‡∏£‡∏∑‡∏≠ cells ‡πÄ‡∏õ‡πá‡∏ô array ‡∏ß‡πà‡∏≤‡∏á)
      if (!setCard.cells || setCard.cells.length === 0) {
        // 2.1.4 ‡πÄ‡∏ã‡∏ï‡∏ß‡πà‡∏≤‡∏á‡∏Ñ‡∏≠‡∏°‡∏û‡∏•‡∏µ‡πÄ‡∏°‡∏ô‡∏ï‡πå: ‡πÑ‡∏î‡πâ‡∏™‡∏°‡∏≤‡∏ä‡∏¥‡∏Å‡∏ó‡∏±‡πâ‡∏á‡∏´‡∏°‡∏î‡∏ö‡∏ô‡∏Å‡∏£‡∏∞‡∏î‡∏≤‡∏ô (‡∏ó‡∏∏‡∏Å‡∏ä‡πà‡∏≠‡∏á)
        console.log('üî• DEBUG: Complement of empty set detected');
        const allCells = [];
        for (let row = 0; row < 8; row++) {
          for (let col = 0; col < 8; col++) {
            allCells.push(`${String.fromCharCode(65 + row)}${col + 1}`);
          }
        }
        resultCells = allCells;
        console.log(`üî• DEBUG: Complement of empty set - got ${allCells.length} cells`);
      } else {
        // 3. ‡πÄ‡∏ã‡∏ï‡πÉ‡∏î ‡πÜ ‡∏Ñ‡∏≠‡∏°‡∏û‡∏•‡∏µ‡πÄ‡∏°‡∏ô‡∏ï‡πå: ‡∏¢‡∏∂‡∏î‡∏ó‡∏∏‡∏Å‡∏ä‡πà‡∏≠‡∏á‡∏ö‡∏ô‡∏Å‡∏£‡∏∞‡∏î‡∏≤‡∏ô ‡∏¢‡∏Å‡πÄ‡∏ß‡πâ‡∏ô‡∏ä‡πà‡∏≠‡∏á‡∏ö‡∏ô‡∏Å‡∏≤‡∏£‡πå‡∏î‡πÄ‡∏ã‡∏ï
        console.log('üî• DEBUG: Complement of normal set detected');
        console.log('üî• DEBUG: Set cells:', setCard.cells);
        console.log('üî• DEBUG: Set size:', setCard.cells.length);
        
        // ‡∏´‡∏≤‡∏ó‡∏∏‡∏Å‡∏ä‡πà‡∏≠‡∏á‡∏ö‡∏ô‡∏Å‡∏£‡∏∞‡∏î‡∏≤‡∏ô (‡∏ó‡∏±‡πâ‡∏á‡∏ó‡∏µ‡πà‡∏°‡∏µ‡πÅ‡∏•‡∏∞‡πÑ‡∏°‡πà‡∏°‡∏µ‡πÄ‡∏ö‡∏µ‡πâ‡∏¢)
        const allCells = [];
        for (let row = 0; row < 8; row++) {
          for (let col = 0; col < 8; col++) {
            allCells.push(`${String.fromCharCode(65 + row)}${col + 1}`);
          }
        }
        
        // ‡∏¢‡∏Å‡πÄ‡∏ß‡πâ‡∏ô‡∏û‡∏∑‡πâ‡∏ô‡∏ó‡∏µ‡πà‡∏ó‡∏µ‡πà‡∏≠‡∏¢‡∏π‡πà‡πÉ‡∏ô‡∏Å‡∏≤‡∏£‡πå‡∏î‡πÄ‡∏ã‡∏ï
        resultCells = allCells.filter(pos => !setCard.cells.includes(pos));
        
        console.log(`üî• DEBUG: Total cells: ${allCells.length}, Set cells: ${setCard.cells.length}, Result: ${resultCells.length}`);
        console.log('üî• DEBUG: Expected result:', allCells.length - setCard.cells.length);
        console.log('üî• DEBUG: Result cells (first 10):', resultCells.slice(0, 10));
      }
      break;
  }
  
  // ‡∏´‡∏≤‡∏Å‡∏Å‡∏≤‡∏£‡∏î‡∏≥‡πÄ‡∏ô‡∏¥‡∏ô‡∏Å‡∏≤‡∏£‡πÑ‡∏°‡πà‡πÄ‡∏Å‡∏¥‡∏î‡∏ú‡∏•‡πÉ‡∏î‡πÜ ‡∏Å‡πá‡∏õ‡∏•‡πà‡∏≠‡∏¢‡πÉ‡∏´‡πâ‡πÄ‡∏Å‡∏¥‡∏î‡∏Å‡∏≤‡∏£‡∏î‡∏≥‡πÄ‡∏ô‡∏¥‡∏ô‡∏Å‡∏≤‡∏£‡πÑ‡∏î‡πâ (‡∏ï‡∏≤‡∏°‡∏Ñ‡∏≥‡∏Ç‡∏≠‡∏ú‡∏π‡πâ‡πÉ‡∏ä‡πâ)
  // ‡πÄ‡∏â‡∏û‡∏≤‡∏∞ Difference ‡∏ó‡∏µ‡πà‡πÑ‡∏°‡πà‡πÑ‡∏î‡πâ‡∏û‡∏∑‡πâ‡∏ô‡∏ó‡∏µ‡πà‡πÄ‡∏û‡∏¥‡πà‡∏°‡πÄ‡∏ó‡πà‡∏≤‡∏ô‡∏±‡πâ‡∏ô‡∏ó‡∏µ‡πà‡∏ï‡πâ‡∏≠‡∏á‡∏Ç‡πâ‡∏≤‡∏°‡∏Å‡∏≤‡∏£‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö
  console.log(`${markerCard.subtype} operation result:`, resultCells ? resultCells.length : 0, 'cells');
  
  // ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡∏Ñ‡∏ß‡∏≤‡∏°‡∏ñ‡∏π‡∏Å‡∏ï‡πâ‡∏≠‡∏á‡∏Ç‡∏≠‡∏á‡∏ï‡∏≥‡πÅ‡∏´‡∏ô‡πà‡∏á
  const validCells = resultCells.filter(pos => {
    const letter = pos.charAt(0);
    const number = parseInt(pos.charAt(1));
    return letter >= 'A' && letter <= 'H' && number >= 1 && number <= 8;
  });
  
  if(validCells.length !== resultCells.length) {
    alert('‡∏û‡∏ö‡∏ï‡∏≥‡πÅ‡∏´‡∏ô‡πà‡∏á‡∏ó‡∏µ‡πà‡πÑ‡∏°‡πà‡∏ñ‡∏π‡∏Å‡∏ï‡πâ‡∏≠‡∏á‡πÉ‡∏ô‡∏Å‡∏≤‡∏£‡∏î‡∏≥‡πÄ‡∏ô‡∏¥‡∏ô‡∏Å‡∏≤‡∏£!');
    return;
  }
  
  resultCells = validCells;
  
  // ‡∏ß‡∏≤‡∏á‡πÄ‡∏ö‡∏µ‡πâ‡∏¢‡∏ï‡∏≤‡∏°‡∏ú‡∏•‡∏•‡∏±‡∏û‡∏ò‡πå (‡∏¢‡∏Å‡πÄ‡∏ß‡πâ‡∏ô Difference ‡∏ó‡∏µ‡πà‡πÑ‡∏°‡πà‡πÑ‡∏î‡πâ‡∏û‡∏∑‡πâ‡∏ô‡∏ó‡∏µ‡πà‡πÄ‡∏û‡∏¥‡πà‡∏°)
  let capturedTokens = 0; // ‡∏õ‡∏£‡∏∞‡∏Å‡∏≤‡∏®‡∏ï‡∏±‡∏ß‡πÅ‡∏õ‡∏£‡πÉ‡∏´‡πâ‡∏≠‡∏¢‡∏π‡πà‡πÉ‡∏ô‡∏Ç‡∏≠‡∏ö‡πÄ‡∏Ç‡∏ï‡∏ó‡∏µ‡πà‡πÉ‡∏ä‡πâ‡πÑ‡∏î‡πâ‡∏ó‡∏±‡πà‡∏ß‡∏ó‡∏±‡πâ‡∏á‡∏ü‡∏±‡∏á‡∏Å‡πå‡∏ä‡∏±‡∏ô
  
  console.log('üî• DEBUG: About to place tokens for', markerCard.subtype);
  console.log('üî• DEBUG: ResultCells length:', resultCells ? resultCells.length : 0);
  
  if(markerCard.subtype !== 'difference') {
    // ‡∏≠‡∏ô‡∏∏‡∏ç‡∏≤‡∏ï‡πÉ‡∏´‡πâ‡∏ó‡∏≥‡∏á‡∏≤‡∏ô‡πÅ‡∏°‡πâ‡πÑ‡∏°‡πà‡∏°‡∏µ resultCells (‡∏Å‡∏£‡∏ì‡∏µ‡∏Å‡∏≤‡∏£‡∏î‡∏≥‡πÄ‡∏ô‡∏¥‡∏ô‡∏Å‡∏≤‡∏£‡∏ß‡πà‡∏≤‡∏á)
    if(resultCells && resultCells.length > 0) {
      const originalTokens = resultCells.filter(pos => gameState.board[pos] === gameState.currentPlayer).length;
      capturedTokens = resultCells.filter(pos => gameState.board[pos] && gameState.board[pos] !== gameState.currentPlayer).length;
      
      console.log(`üî• DEBUG: Placing tokens on ${resultCells.length} cells`);
      console.log('üî• DEBUG: First 10 cells:', resultCells.slice(0, 10));
      
      try {
        resultCells.forEach(pos => {
          gameState.board[pos] = gameState.currentPlayer;
          const cell = document.querySelector(`[data-position="${pos}"]`);
          if(cell) {
            const chip = document.createElement('div');
            chip.className = `chip ${gameState.currentPlayer}`;
            chip.textContent = gameState.currentPlayer === 'black' ? '‚ö´' : '‚ö™';
            cell.innerHTML = '';
            cell.appendChild(chip);
            
            // ‡πÄ‡∏û‡∏¥‡πà‡∏°‡∏™‡∏µ‡∏û‡∏∑‡πâ‡∏ô‡∏´‡∏•‡∏±‡∏á‡πÅ‡∏™‡∏î‡∏á‡∏Å‡∏≤‡∏£‡∏Ñ‡∏£‡∏≠‡∏ö‡∏Ñ‡∏£‡∏≠‡∏á
            cell.style.backgroundColor = gameState.currentPlayer === 'black' ? '#f3f4f6' : '#fef3c7';
          } else {
            console.error(`Cannot find cell for position: ${pos}`);
          }
        });
        
        updateTokenCounts();
        console.log(`Successfully placed tokens. New board state:`, gameState.board);
      } catch (error) {
        console.error('Error placing tokens:', error);
        alert('‡πÄ‡∏Å‡∏¥‡∏î‡∏Ç‡πâ‡∏≠‡∏ú‡∏¥‡∏î‡∏û‡∏•‡∏≤‡∏î‡πÉ‡∏ô‡∏Å‡∏≤‡∏£‡∏ß‡∏≤‡∏á‡πÄ‡∏ö‡∏µ‡πâ‡∏¢: ' + error.message);
        return;
      }
    } else {
      console.log(`${markerCard.subtype} operation completed with no cells to place`);
    }
  }
  try {
    gameState.cardsPlacedThisTurn.set = true;
    gameState.cardsPlacedThisTurn.marker = true;
    
    // ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö Difference ‡∏à‡∏∞‡∏°‡∏µ‡∏Å‡∏≤‡∏£ log ‡∏Ç‡πâ‡∏≠‡∏Ñ‡∏ß‡∏≤‡∏°‡πÅ‡∏•‡πâ‡∏ß‡πÉ‡∏ô‡∏Ç‡∏±‡πâ‡∏ô‡∏ï‡∏≠‡∏ô‡∏Å‡∏≤‡∏£‡∏•‡∏ö‡πÄ‡∏ö‡∏µ‡πâ‡∏¢
    if(markerCard.subtype !== 'difference') {
      const playerName = gameState.currentPlayer === 'black' ? '‡∏ú‡∏π‡πâ‡πÄ‡∏•‡πà‡∏ô‡∏î‡∏≥' : '‡∏ú‡∏π‡πâ‡πÄ‡∏•‡πà‡∏ô‡∏Ç‡∏≤‡∏ß';
      const cellCount = resultCells ? resultCells.length : 0;
      let logMsg = `${playerName} ‡πÉ‡∏ä‡πâ ${setCard.label} + ${markerCard.label}`;
      
      if (cellCount > 0) {
        logMsg += ` ‡πÑ‡∏î‡πâ ${cellCount} ‡∏ä‡πà‡∏≠‡∏á`;
        if (markerCard.subtype === 'union' && capturedTokens > 0) {
          logMsg += ` (‡∏£‡∏ß‡∏°‡πÄ‡∏ö‡∏µ‡πâ‡∏¢‡∏ï‡∏¥‡∏î‡∏Å‡∏±‡∏ô ${capturedTokens} ‡∏ä‡πà‡∏≠‡∏á)`;
        }
      } else {
        logMsg += ` (‡πÑ‡∏°‡πà‡∏°‡∏µ‡∏Å‡∏≤‡∏£‡πÄ‡∏õ‡∏•‡∏µ‡πà‡∏¢‡∏ô‡πÅ‡∏õ‡∏•‡∏á)`;
      }
      
      logMessage(logMsg);
    }
    
    // ‡∏•‡∏ö‡∏Å‡∏≤‡∏£‡πå‡∏î‡∏ó‡∏µ‡πà‡πÉ‡∏ä‡πâ‡∏ó‡∏±‡πâ‡∏á‡∏™‡∏≠‡∏á‡πÉ‡∏ö
    const setIndex = gameState.selectedCards.find(i => gameState.players[gameState.currentPlayer].hand[i].type === 'set');
    const markerIndex = gameState.selectedCards.find(i => gameState.players[gameState.currentPlayer].hand[i].type === 'marker');
    
    if (setIndex === undefined || markerIndex === undefined) {
      console.error('Cannot find card indices:', { setIndex, markerIndex, selectedCards: gameState.selectedCards });
      throw new Error('‡πÑ‡∏°‡πà‡∏û‡∏ö‡∏Å‡∏≤‡∏£‡πå‡∏î‡∏ó‡∏µ‡πà‡πÄ‡∏•‡∏∑‡∏≠‡∏Å');
    }
    
    const allIndices = [setIndex, markerIndex].sort((a, b) => b - a);
    allIndices.forEach(index => {
      if (index >= 0 && index < gameState.players[gameState.currentPlayer].hand.length) {
        gameState.players[gameState.currentPlayer].hand.splice(index, 1);
      } else {
        console.error(`Invalid card index: ${index}`);
      }
    });
    
    gameState.selectedCards = [];
    updateDisplay();
    
    updateGameStatus('‡∏Å‡∏î‡∏Ç‡πâ‡∏≤‡∏°‡πÄ‡∏ó‡∏¥‡∏£‡πå‡∏ô‡πÄ‡∏û‡∏∑‡πà‡∏≠‡∏à‡∏ö‡πÄ‡∏ó‡∏¥‡∏£‡πå‡∏ô');
    enableButtons(['skipTurnBtn']);
  } catch (error) {
    console.error('Error in applySetWithMarker cleanup:', error);
    alert('‡πÄ‡∏Å‡∏¥‡∏î‡∏Ç‡πâ‡∏≠‡∏ú‡∏¥‡∏î‡∏û‡∏•‡∏≤‡∏î‡πÉ‡∏ô‡∏Å‡∏≤‡∏£‡∏à‡∏±‡∏î‡∏Å‡∏≤‡∏£‡∏Å‡∏≤‡∏£‡πå‡∏î: ' + error.message);
  }
};

// ‡∏ó‡∏¥‡πâ‡∏á‡∏Å‡∏≤‡∏£‡πå‡∏î
const discardCard = () => {
  if(gameState.turnPhase !== 'action') {
    alert('‡∏ï‡πâ‡∏≠‡∏á‡∏à‡∏±‡πà‡∏ß‡∏Å‡∏≤‡∏£‡πå‡∏î‡∏Å‡πà‡∏≠‡∏ô‡∏ó‡∏¥‡πâ‡∏á‡∏Å‡∏≤‡∏£‡πå‡∏î!');
    return;
  }
  
  if(gameState.selectedCards.length !== 1) {
    alert('‡πÄ‡∏•‡∏∑‡∏≠‡∏Å‡∏Å‡∏≤‡∏£‡πå‡∏î 1 ‡πÉ‡∏ö‡∏ó‡∏µ‡πà‡∏ï‡πâ‡∏≠‡∏á‡∏Å‡∏≤‡∏£‡∏ó‡∏¥‡πâ‡∏á!');
    return;
  }
  
  const cardIndex = gameState.selectedCards[0];
  const card = gameState.players[gameState.currentPlayer].hand[cardIndex];
  
  gameState.players[gameState.currentPlayer].hand.splice(cardIndex, 1);
  gameState.selectedCards = [];
  
  const playerName = getPlayerName(gameState.currentPlayer);
  logMessage(`${playerName} ‡∏ó‡∏¥‡πâ‡∏á‡∏Å‡∏≤‡∏£‡πå‡∏î: ${card.label}`);
  
  updateDisplay();
  
  // ‡∏à‡∏ö‡πÄ‡∏ó‡∏¥‡∏£‡πå‡∏ô‡∏ó‡∏±‡∏ô‡∏ó‡∏µ‡∏´‡∏•‡∏±‡∏á‡∏ó‡∏¥‡πâ‡∏á‡∏Å‡∏≤‡∏£‡πå‡∏î
  setTimeout(() => {
    skipTurn();
  }, 1000);
  
  updateGameStatus('‡∏ó‡∏¥‡πâ‡∏á‡∏Å‡∏≤‡∏£‡πå‡∏î‡πÅ‡∏•‡πâ‡∏ß - ‡∏à‡∏∞‡∏à‡∏ö‡πÄ‡∏ó‡∏¥‡∏£‡πå‡∏ô‡πÉ‡∏ô‡∏≠‡∏µ‡∏Å 1 ‡∏ß‡∏¥‡∏ô‡∏≤‡∏ó‡∏µ...');
  enableButtons([]);
};

// ‡∏Ç‡πâ‡∏≤‡∏°‡πÄ‡∏ó‡∏¥‡∏£‡πå‡∏ô
const skipTurn = () => {
  if(gameState.phase === 'playing' && gameState.turnPhase === 'draw' && !gameState.drawnThisTurn) {
    alert('‡∏ï‡πâ‡∏≠‡∏á‡∏à‡∏±‡πà‡∏ß‡∏Å‡∏≤‡∏£‡πå‡∏î‡∏Å‡πà‡∏≠‡∏ô‡∏Ç‡πâ‡∏≤‡∏°‡πÄ‡∏ó‡∏¥‡∏£‡πå‡∏ô!');
    return;
  }
  
  const playerName = gameState.currentPlayer === 'black' ? '‡∏ú‡∏π‡πâ‡πÄ‡∏•‡πà‡∏ô‡∏î‡∏≥' : '‡∏ú‡∏π‡πâ‡πÄ‡∏•‡πà‡∏ô‡∏Ç‡∏≤‡∏ß';
  
  if(gameState.phase === 'playing') {
    // ‡∏ñ‡πâ‡∏≤‡∏≠‡∏¢‡∏π‡πà‡πÉ‡∏ô‡∏ä‡πà‡∏ß‡∏á action ‡πÉ‡∏´‡πâ‡∏à‡∏ö‡πÄ‡∏ó‡∏¥‡∏£‡πå‡∏ô‡∏ó‡∏±‡∏ô‡∏ó‡∏µ
    if(gameState.turnPhase === 'action') {
      logMessage(`${playerName} ‡∏Ç‡πâ‡∏≤‡∏°‡∏Å‡∏≤‡∏£‡πÉ‡∏ä‡πâ‡∏™‡∏¥‡∏ó‡∏ò‡∏¥‡πå`);
    } else {
      logMessage(`${playerName} ‡∏à‡∏ö‡πÄ‡∏ó‡∏¥‡∏£‡πå‡∏ô`);
    }
    
    // ‡πÄ‡∏õ‡∏•‡∏µ‡πà‡∏¢‡∏ô‡∏ú‡∏π‡πâ‡πÄ‡∏•‡πà‡∏ô
    gameState.currentPlayer = gameState.currentPlayer === 'black' ? 'white' : 'black';
    if(gameState.currentPlayer === 'black') {
      gameState.turn++;
    }
    
    // ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡∏à‡∏ö‡πÄ‡∏Å‡∏° - ‡πÄ‡∏≠‡∏≤‡πÄ‡∏á‡∏∑‡πà‡∏≠‡∏ô‡πÑ‡∏Ç‡πÄ‡∏ó‡∏¥‡∏£‡πå‡∏ô‡∏≠‡∏≠‡∏Å ‡πÉ‡∏´‡πâ‡∏ú‡∏π‡πâ‡πÄ‡∏•‡πà‡∏ô‡πÄ‡∏•‡∏∑‡∏≠‡∏Å‡∏à‡∏ö‡πÄ‡∏Å‡∏°‡πÄ‡∏≠‡∏á
    // if(gameState.turn > 20) {
    //   endGame();
    //   return;
    // }
    
    // ‡∏£‡∏µ‡πÄ‡∏ã‡πá‡∏ï‡∏™‡∏ñ‡∏≤‡∏ô‡∏∞‡πÄ‡∏ó‡∏¥‡∏£‡πå‡∏ô
    gameState.turnPhase = 'draw';
    gameState.drawnThisTurn = false;
    gameState.cardsPlacedThisTurn = { set: false, marker: false };
    gameState.selectedCards = [];
    
    // ‡∏£‡∏µ‡πÄ‡∏ã‡πá‡∏ï‡∏õ‡∏∏‡πà‡∏°‡∏ó‡∏±‡πâ‡∏á‡∏´‡∏°‡∏î‡∏Å‡πà‡∏≠‡∏ô update
    enableButtons([]);
    
    updateDisplay();
    
    const nextPlayerName = getPlayerName(gameState.currentPlayer);
    
    updateGameStatus(`${nextPlayerName}: ‡∏à‡∏±‡πà‡∏ß‡∏Å‡∏≤‡∏£‡πå‡∏î 1 ‡πÉ‡∏ö‡∏Å‡πà‡∏≠‡∏ô`);
    enableButtons(['drawSetBtn', 'drawMarkerBtn']);
  }
};

// ‡∏à‡∏ö‡πÄ‡∏Å‡∏°
const endGame = () => {
  gameState.phase = 'finished';
  
  const blackScore = calculateScore('black');
  const whiteScore = calculateScore('white');
  
  const blackPlayerName = getPlayerName('black');
  const whitePlayerName = getPlayerName('white');
  
  let winner, message;
  if(blackScore > whiteScore) {
    winner = `${blackPlayerName}‡∏ä‡∏ô‡∏∞!`;
    message = `üéâ ${blackPlayerName}‡∏ä‡∏ô‡∏∞! (${blackScore} > ${whiteScore})`;
  } else if(whiteScore > blackScore) {
    winner = `${whitePlayerName}‡∏ä‡∏ô‡∏∞!`;
    message = `üéâ ${whitePlayerName}‡∏ä‡∏ô‡∏∞! (${whiteScore} > ${blackScore})`;
  } else {
    winner = '‡πÄ‡∏™‡∏°‡∏≠‡∏Å‡∏±‡∏ô!';
    message = `ü§ù ‡πÄ‡∏™‡∏°‡∏≠‡∏Å‡∏±‡∏ô! (${blackScore} = ${whiteScore})`;
  }
  
  logMessage('üèÅ ‡∏à‡∏ö‡πÄ‡∏Å‡∏°! ‡∏ú‡∏•‡∏Å‡∏≤‡∏£‡πÅ‡∏Ç‡πà‡∏á‡∏Ç‡∏±‡∏ô:');
  logMessage(`   ${blackPlayerName}: ${blackScore} ‡∏Ñ‡∏∞‡πÅ‡∏ô‡∏ô (‡πÄ‡∏ö‡∏µ‡πâ‡∏¢ ${gameState.players.black.tokens} - ‡∏Å‡∏≤‡∏£‡πå‡∏î ${gameState.players.black.hand.length})`);
  logMessage(`   ${whitePlayerName}: ${whiteScore} ‡∏Ñ‡∏∞‡πÅ‡∏ô‡∏ô (‡πÄ‡∏ö‡∏µ‡πâ‡∏¢ ${gameState.players.white.tokens} - ‡∏Å‡∏≤‡∏£‡πå‡∏î ${gameState.players.white.hand.length})`);
  logMessage(message);
  
  updateDisplay();
  updateGameStatus('‡πÄ‡∏Å‡∏°‡∏à‡∏ö‡πÅ‡∏•‡πâ‡∏ß! ‡∏Å‡∏î‡πÄ‡∏£‡∏¥‡πà‡∏°‡πÄ‡∏Å‡∏°‡πÉ‡∏´‡∏°‡πà‡πÄ‡∏û‡∏∑‡πà‡∏≠‡πÄ‡∏•‡πà‡∏ô‡∏≠‡∏µ‡∏Å‡∏Ñ‡∏£‡∏±‡πâ‡∏á');
  enableButtons([]);
};

// Loading state helpers
const setButtonLoading = (buttonId, loading = true, originalText = '') => {
  const button = document.getElementById(buttonId);
  if (!button) return;
  
  if (loading) {
    button.dataset.originalText = button.textContent;
    button.classList.add('loading');
    button.disabled = true;
  } else {
    button.classList.remove('loading');
    button.textContent = originalText || button.dataset.originalText;
    delete button.dataset.originalText;
  }
};

// Enhanced action functions with loading states
const drawSetCardWithLoading = async () => {
  setButtonLoading('drawSetBtn', true);
  try {
    await new Promise(resolve => setTimeout(resolve, 300)); // Simulate processing
    drawSetCard();
  } finally {
    setTimeout(() => setButtonLoading('drawSetBtn', false), 100);
  }
};

const drawMarkerCardWithLoading = async () => {
  setButtonLoading('drawMarkerBtn', true);
  try {
    await new Promise(resolve => setTimeout(resolve, 300));
    drawMarkerCard();
  } finally {
    setTimeout(() => setButtonLoading('drawMarkerBtn', false), 100);
  }
};

const placeCardsWithLoading = async () => {
  setButtonLoading('placeCardsBtn', true);
  try {
    await new Promise(resolve => setTimeout(resolve, 400)); // Longer for placement
    placeCards();
  } finally {
    setTimeout(() => setButtonLoading('placeCardsBtn', false), 100);
  }
};

const discardCardWithLoading = async () => {
  setButtonLoading('discardBtn', true);
  try {
    await new Promise(resolve => setTimeout(resolve, 200));
    discardCard();
  } finally {
    setTimeout(() => setButtonLoading('discardBtn', false), 100);
  }
};

const skipTurnWithLoading = async () => {
  setButtonLoading('skipTurnBtn', true);
  try {
    await new Promise(resolve => setTimeout(resolve, 250));
    skipTurn();
  } finally {
    setTimeout(() => setButtonLoading('skipTurnBtn', false), 100);
  }
};

// Event Listeners
document.getElementById('newGameBtn').onclick = startNewGame;
document.getElementById('drawSetBtn').onclick = drawSetCardWithLoading;
document.getElementById('drawMarkerBtn').onclick = drawMarkerCardWithLoading;
document.getElementById('placeCardsBtn').onclick = placeCardsWithLoading;
document.getElementById('discardBtn').onclick = discardCardWithLoading;
document.getElementById('skipTurnBtn').onclick = skipTurnWithLoading;

// ‡∏ü‡∏±‡∏á‡∏Å‡πå‡∏ä‡∏±‡∏ô‡πÅ‡∏™‡∏î‡∏á/‡∏ã‡πà‡∏≠‡∏ô‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏Å‡∏≤‡∏£‡πå‡∏î
const toggleCardInfo = () => {
  const content = document.getElementById('card-info-content');
  const icon = document.getElementById('toggle-icon');
  const text = document.getElementById('toggle-text');
  
  if (content.classList.contains('show')) {
    content.classList.remove('show');
    icon.textContent = 'üëÅÔ∏è';
    text.textContent = '‡πÅ‡∏™‡∏î‡∏á‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏Å‡∏≤‡∏£‡πå‡∏î';
  } else {
    content.classList.add('show');
    icon.textContent = 'üôà';
    text.textContent = '‡∏ã‡πà‡∏≠‡∏ô‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏Å‡∏≤‡∏£‡πå‡∏î';
  }
};

// ‡∏ü‡∏±‡∏á‡∏Å‡πå‡∏ä‡∏±‡∏ô‡∏≠‡∏±‡∏û‡πÄ‡∏î‡∏ó‡∏Å‡∏≤‡∏£‡∏ô‡∏±‡∏ö‡∏Å‡∏≤‡∏£‡πå‡∏î‡∏Ñ‡∏á‡πÄ‡∏´‡∏•‡∏∑‡∏≠
const updateCardCounts = () => {
  const setElement = document.getElementById('remaining-set-cards');
  const markerElement = document.getElementById('remaining-marker-cards');
  
  if (setElement && gameState && gameState.deckSet) {
    setElement.textContent = `‡πÄ‡∏´‡∏•‡∏∑‡∏≠‡πÉ‡∏ô‡πÄ‡∏î‡πá‡∏Ñ: ${gameState.deckSet.length} ‡πÉ‡∏ö`;
  }
  
  if (markerElement && gameState && gameState.deckMarker) {
    markerElement.textContent = `‡πÄ‡∏´‡∏•‡∏∑‡∏≠‡πÉ‡∏ô‡πÄ‡∏î‡πá‡∏Ñ: ${gameState.deckMarker.length} ‡πÉ‡∏ö`;
  }
};

// ‡πÄ‡∏£‡∏¥‡πà‡∏°‡∏ï‡πâ‡∏ô
createBoard();
updateDisplay();
enableButtons([]);
</script>
</body>
</html>
