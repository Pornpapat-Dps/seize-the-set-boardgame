<!DOCTYPE html>
<html lang="th">
<head>
    <meta charset="UTF-8">
    <title>üîß Real-time Debug Monitor</title>
    <style>
        body { 
            font-family: 'Courier New', monospace; 
            margin: 10px; 
            background-color: #1e1e1e; 
            color: #00ff00; 
        }
        h1 { color: #00ccff; }
        .debug-section { 
            border: 1px solid #555; 
            margin: 10px 0; 
            padding: 10px; 
            background-color: #2a2a2a; 
        }
        .debug-log { 
            height: 200px; 
            overflow-y: scroll; 
            background-color: #000; 
            padding: 10px; 
            border: 1px solid #333;
            white-space: pre-wrap;
            font-size: 12px;
        }
        .board-mini { 
            display: grid; 
            grid-template-columns: repeat(8, 25px); 
            gap: 1px; 
            margin: 10px 0; 
        }
        .cell-mini { 
            width: 25px; 
            height: 25px; 
            border: 1px solid #666; 
            display: flex; 
            align-items: center; 
            justify-content: center; 
            font-size: 8px;
            background-color: #333;
        }
        .black-token { background-color: #000; color: white; }
        .white-token { background-color: #ddd; color: black; }
        button { 
            background-color: #0066cc; 
            color: white; 
            border: none; 
            padding: 8px 12px; 
            margin: 5px; 
            cursor: pointer;
        }
        button:hover { background-color: #0088ff; }
        .status { color: #ffff00; font-weight: bold; }
        .error { color: #ff6666; }
        .success { color: #66ff66; }
    </style>
</head>
<body>
    <h1>üîß Set Operations Debug Monitor</h1>
    
    <div class="debug-section">
        <h2>üéØ Quick Tests</h2>
        <button onclick="testIntersectionQuick()">Test Intersection + Empty</button>
        <button onclick="testComplement2x2Quick()">Test Complement + 2x2</button>
        <button onclick="testComplement4x4Quick()">Test Complement + 4x4</button>
        <button onclick="clearAllLogs()">Clear Logs</button>
    </div>
    
    <div class="debug-section">
        <h2>üîç Intersection Debug</h2>
        <div id="intersectionStatus" class="status">Ready...</div>
        <div id="intersectionLog" class="debug-log"></div>
        <div id="intersectionBoard" class="board-mini"></div>
    </div>
    
    <div class="debug-section">
        <h2>üìê Complement Debug</h2>
        <div id="complementStatus" class="status">Ready...</div>
        <div id="complementLog" class="debug-log"></div>
        <div id="complementBoard" class="board-mini"></div>
    </div>

    <script>
        let debugLogs = {
            intersection: '',
            complement: ''
        };
        
        function logToSection(section, message, type = 'info') {
            const timestamp = new Date().toLocaleTimeString();
            const colorClass = type === 'error' ? 'error' : type === 'success' ? 'success' : '';
            const formattedMessage = `[${timestamp}] ${message}`;
            
            debugLogs[section] += formattedMessage + '\n';
            
            const logElement = document.getElementById(`${section}Log`);
            if (logElement) {
                logElement.textContent = debugLogs[section];
                logElement.scrollTop = logElement.scrollHeight;
            }
            
            console.log(`${section.toUpperCase()}: ${formattedMessage}`);
        }
        
        function setStatus(section, message, type = 'info') {
            const statusElement = document.getElementById(`${section}Status`);
            if (statusElement) {
                statusElement.textContent = message;
                statusElement.className = `status ${type}`;
            }
        }
        
        function displayMiniBoard(boardData, containerId, highlights = []) {
            const container = document.getElementById(containerId);
            if (!container) return;
            
            container.innerHTML = '';
            
            for (let row = 0; row < 8; row++) {
                for (let col = 0; col < 8; col++) {
                    const pos = `${String.fromCharCode(65 + row)}${col + 1}`;
                    const cell = document.createElement('div');
                    cell.className = 'cell-mini';
                    
                    if (boardData[pos] === 'black') {
                        cell.classList.add('black-token');
                        cell.textContent = '‚ö´';
                    } else if (boardData[pos] === 'white') {
                        cell.classList.add('white-token');
                        cell.textContent = '‚ö™';
                    } else {
                        cell.textContent = pos.slice(-1);
                    }
                    
                    if (highlights.includes(pos)) {
                        cell.style.border = '2px solid yellow';
                    }
                    
                    container.appendChild(cell);
                }
            }
        }
        
        function clearAllLogs() {
            debugLogs.intersection = '';
            debugLogs.complement = '';
            document.getElementById('intersectionLog').textContent = '';
            document.getElementById('complementLog').textContent = '';
            setStatus('intersection', 'Logs cleared');
            setStatus('complement', 'Logs cleared');
        }
        
        function testIntersectionQuick() {
            setStatus('intersection', 'Testing Intersection + Empty Set...', 'info');
            logToSection('intersection', '=== TESTING INTERSECTION + EMPTY SET ===');
            
            // Create test board
            const mockBoard = {
                'A1': 'black', 'A2': 'white', 'A3': 'black',
                'B1': 'white', 'B2': 'black', 'B3': 'white',
                'C1': 'black', 'C2': 'white'
            };
            
            logToSection('intersection', `Initial board: ${Object.keys(mockBoard).length} tokens`);
            
            const currentPlayer = 'black';
            const opponentColor = 'white';
            
            // Count tokens before
            const opponentsBefore = Object.keys(mockBoard).filter(pos => mockBoard[pos] === opponentColor);
            const playerBefore = Object.keys(mockBoard).filter(pos => mockBoard[pos] === currentPlayer);
            
            logToSection('intersection', `Before: Player(${currentPlayer}): ${playerBefore.length}, Opponent(${opponentColor}): ${opponentsBefore.length}`);
            logToSection('intersection', `Opponent tokens: ${opponentsBefore.join(', ')}`);
            
            // Simulate intersection with empty set
            const setCard = { cells: [] };
            
            if (!setCard.cells || setCard.cells.length === 0) {
                logToSection('intersection', 'Empty set detected - removing opponent tokens');
                
                // Find and remove opponent tokens
                const opponentTokens = [];
                for (let row = 0; row < 8; row++) {
                    for (let col = 0; col < 8; col++) {
                        const pos = `${String.fromCharCode(65 + row)}${col + 1}`;
                        if (mockBoard[pos] === opponentColor) {
                            opponentTokens.push(pos);
                        }
                    }
                }
                
                logToSection('intersection', `Found ${opponentTokens.length} opponent tokens to remove`);
                
                opponentTokens.forEach(pos => {
                    delete mockBoard[pos];
                    logToSection('intersection', `Removed token at ${pos}`);
                });
            }
            
            // Check results
            const remainingTokens = Object.keys(mockBoard);
            const opponentsAfter = remainingTokens.filter(pos => mockBoard[pos] === opponentColor);
            const playersAfter = remainingTokens.filter(pos => mockBoard[pos] === currentPlayer);
            
            logToSection('intersection', `After: Player: ${playersAfter.length}, Opponent: ${opponentsAfter.length}`);
            
            const success = opponentsAfter.length === 0 && playersAfter.length === playerBefore.length;
            
            if (success) {
                logToSection('intersection', '‚úÖ SUCCESS: All opponent tokens removed!', 'success');
                setStatus('intersection', 'TEST PASSED', 'success');
            } else {
                logToSection('intersection', '‚ùå FAILED: Some opponent tokens remain', 'error');
                setStatus('intersection', 'TEST FAILED', 'error');
            }
            
            displayMiniBoard(mockBoard, 'intersectionBoard');
        }
        
        function testComplement2x2Quick() {
            setStatus('complement', 'Testing Complement + 2x2 Set...', 'info');
            logToSection('complement', '=== TESTING COMPLEMENT + 2x2 SET ===');
            
            const setCard = { cells: ['A1', 'A2', 'B1', 'B2'] };
            logToSection('complement', `Set cells: ${setCard.cells.join(', ')}`);
            
            // Generate all cells
            const allCells = [];
            for (let row = 0; row < 8; row++) {
                for (let col = 0; col < 8; col++) {
                    allCells.push(`${String.fromCharCode(65 + row)}${col + 1}`);
                }
            }
            
            logToSection('complement', `Total board cells: ${allCells.length}`);
            
            // Calculate complement
            const resultCells = allCells.filter(pos => !setCard.cells.includes(pos));
            
            logToSection('complement', `Complement calculation: ${allCells.length} - ${setCard.cells.length} = ${resultCells.length}`);
            logToSection('complement', `Expected: 60, Actual: ${resultCells.length}`);
            
            // Verify no set cells in result
            const setInResult = setCard.cells.filter(pos => resultCells.includes(pos));
            logToSection('complement', `Set cells in result (should be 0): ${setInResult.length}`);
            
            const success = resultCells.length === 60 && setInResult.length === 0;
            
            if (success) {
                logToSection('complement', '‚úÖ SUCCESS: Complement calculation correct!', 'success');
                setStatus('complement', 'TEST PASSED', 'success');
            } else {
                logToSection('complement', '‚ùå FAILED: Incorrect complement calculation', 'error');
                setStatus('complement', 'TEST FAILED', 'error');
            }
            
            // Display result
            const boardDisplay = {};
            resultCells.forEach(pos => boardDisplay[pos] = 'black');
            displayMiniBoard(boardDisplay, 'complementBoard', setCard.cells);
        }
        
        function testComplement4x4Quick() {
            setStatus('complement', 'Testing Complement + 4x4 Set...', 'info');
            logToSection('complement', '=== TESTING COMPLEMENT + 4x4 SET ===');
            
            // Generate 4x4 set
            const setCard = { cells: [] };
            for (let row = 0; row < 4; row++) {
                for (let col = 0; col < 4; col++) {
                    setCard.cells.push(`${String.fromCharCode(65 + row)}${col + 1}`);
                }
            }
            
            logToSection('complement', `4x4 Set: ${setCard.cells.length} cells (A1-D4)`);
            
            // Generate all cells
            const allCells = [];
            for (let row = 0; row < 8; row++) {
                for (let col = 0; col < 8; col++) {
                    allCells.push(`${String.fromCharCode(65 + row)}${col + 1}`);
                }
            }
            
            logToSection('complement', `Total board cells: ${allCells.length}`);
            
            // Calculate complement
            const resultCells = allCells.filter(pos => !setCard.cells.includes(pos));
            
            logToSection('complement', `Complement calculation: ${allCells.length} - ${setCard.cells.length} = ${resultCells.length}`);
            logToSection('complement', `Expected: 48, Actual: ${resultCells.length}`);
            
            // Verify no set cells in result
            const setInResult = setCard.cells.filter(pos => resultCells.includes(pos));
            logToSection('complement', `Set cells in result (should be 0): ${setInResult.length}`);
            
            const success = resultCells.length === 48 && setInResult.length === 0;
            
            if (success) {
                logToSection('complement', '‚úÖ SUCCESS: Complement calculation correct!', 'success');
                setStatus('complement', 'TEST PASSED', 'success');
            } else {
                logToSection('complement', '‚ùå FAILED: Incorrect complement calculation', 'error');
                setStatus('complement', 'TEST FAILED', 'error');
            }
            
            // Display result
            const boardDisplay = {};
            resultCells.forEach(pos => boardDisplay[pos] = 'black');
            displayMiniBoard(boardDisplay, 'complementBoard', setCard.cells);
        }
        
        // Auto-run tests on load
        document.addEventListener('DOMContentLoaded', () => {
            setTimeout(() => {
                logToSection('intersection', 'Debug monitor ready');
                logToSection('complement', 'Debug monitor ready');
            }, 100);
        });
    </script>
</body>
</html>